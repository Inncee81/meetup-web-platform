// @flow

declare type SealOptionsSub = any; // todo: import { SealOptions, SealOptionsSub } from "iron";
declare type SealOptions = any;

declare type HapiRequestUrl = URL & {
	path: string,
};

declare type HapiRoute = Object;

declare type HapiServerStateCookieOptions = {
    /** time-to-live in milliseconds. Defaults to null (session time-life - cookies are deleted when the browser is closed). */
	ttl?: number | null,

    /** sets the 'Secure' flag. Defaults to true. */
	isSecure?: boolean,

    /** sets the 'HttpOnly' flag. Defaults to true. */
	isHttpOnly?: boolean,

    /**
     * sets the 'SameSite' flag. The value must be one of:
     *  * false - no flag.
     *  * 'Strict' - sets the value to 'Strict' (this is the default value).
     *  * 'Lax' - sets the value to 'Lax'.
     */
	isSameSite?: false | 'Strict' | 'Lax',

    /** the path scope. Defaults to null (no path). */
	path?: string | null,

    /** the domain scope. Defaults to null (no domain). */
    domain?: string | null,

    /**
     * if present and the cookie was not received from the client or explicitly set by the route handler, the
     * cookie is automatically added to the response with the provided value. The value can be
     * a function with signature async function(request) where:
     */
	autoValue?: (request: HapiRequest) => void,

    /**
     * encoding performs on the provided value before serialization. Options are:
     *  * 'none' - no encoding. When used, the cookie value must be a string. This is the default value.
     *  * 'base64' - string value is encoded using Base64.
     *  * 'base64json' - object value is JSON-stringified then encoded using Base64.
     *  * 'form' - object value is encoded using the x-www-form-urlencoded method.
     *  * 'iron' - Encrypts and sign the value using iron.
     */
	encoding?: 'none' | 'base64' | 'base64json' | 'form' | 'iron',

    /**
     * an object used to calculate an HMAC for cookie integrity validation. This does not provide privacy, only a mean
     * to verify that the cookie value was generated by the server. Redundant when 'iron' encoding is used. Options are:
     *  * integrity - algorithm options. Defaults to require('iron').defaults.integrity.
     *  * password - password used for HMAC key generation (must be at least 32 characters long).
     */
    sign?: {
        integrity?: SealOptionsSub,
        password: string,
	},

    /** password used for 'iron' encoding (must be at least 32 characters long). */
	password?: string,

    /** options for 'iron' encoding. Defaults to require('iron').defaults. */
	iron?: SealOptions,

    /** if true, errors are ignored and treated as missing cookies. */
	ignoreErrors?: boolean,

    /** if true, automatically instruct the client to remove invalid cookies. Defaults to false. */
	clearInvalid?: boolean,

    /** if false, allows any cookie value including values in violation of RFC 6265. Defaults to true. */
	strictHeader?: boolean,

    /** used by proxy plugins (e.g. h2o2). */
    passThrough?: any;
}

declare type HapiAuthenticationData = {
    credentials: Object,
    artifacts?: Object,
};

declare type HapiServer = {
	app: {
		logger: (...args: Array<any>) => void,
	},
	expose: (key: string, value: any) => void,
	settings: {
		app: { isProd: boolean, supportedLangs: Array<string>, [string]: any },
		api: { host: string, isProd: boolean },
	},
	plugins: {
		[string]: any,
	},
	route: (routes: HapiRoute | Array<HapiRoute>) => Promise<HapiServer>,
	on: (eventName: string, cb: () => void) => void,
};

declare type HapiRequest = {
	getLanguage: () => string,
	getLangPrefixPath: () => string,
	log: (Array<string>, string) => void,
	url: HapiRequestUrl,
	server: HapiServer,
	state: {
		[string]: string,
	},
	info: {
		referrer: string,
		host: string,
		[string]: mixed,
	},
	headers: {
		[string]: string,
	},
	[string]: any,
};

declare type HapiResponseValue = string | Object;

declare type HapiResponseObject = {
	app: any,
	events: any,
	headers: any,
	plugins: any,
	settings: any,
	source: any,
	statusCode: any,
	variety: any,
	bytes: any,
	charset: any,
	code: any,
	message: any,
	created: any,
	encoding: any,
	etag: any,
	header: any,
	location: any,
	redirect: any,
	replacer: any,
	spaces: any,
	state: any,
	suffix: any,
	ttl: any,
	type: any,
	unstate: any,
	vary: any,
	takeover: any,
	temporary: any,
	permanent: any,
	rewritable: any,
};

declare type HapiResponseToolkit = {
	abandon: any,
	close: any,
	context: any,
	continue: any,
	realm: any,
	request: HapiRequest,
	authenticated: (data: HapiAuthenticationData) => Object,
	entity: (options?: {etag?: string, modified?: string, vary?: boolean}) => HapiResponseObject | void,
	redirect: (uri?: string) => HapiResponseObject,
	response: (value?: HapiResponseValue) => HapiResponseObject,
	state: (key: string, value: string | Object, options?: HapiServerStateCookieOptions) => HapiResponseObject,
	unauthenticated: (error: Error, data?: HapiAuthenticationData) => void,
	unstate: (key: string, options?: HapiServerStateCookieOptions) => HapiResponseObject,
};