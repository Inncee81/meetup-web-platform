// @flow

/**
 * @see Typescript HapiJS v17 https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/hapi/index.d.ts

 */

// todo: import { SealOptions, SealOptionsSub } from "iron";
declare type SealOptionsSub = any;
declare type SealOptions = any;

// todo: update to actual values
declare type HapiApplicationState = any;
declare type HapiResponseEvents = any;
declare type HapiPluginsStates = any;
declare type HapiResponseSettings = any;

declare type HapiRequestUrl = URL & {
	path: string,
};

declare type HapiHandlerReturnValue = HapiResponseObject | Error | string | { [string]: any };
declare type HapiHandler = (HapiRequest, HapiResponseToolkit) => HapiHandlerReturnValue | Promise<HapiHandlerReturnValue>;

declare type HapiRoute = Object;

declare type HapiResponseObjectHeaderOptions = {
    append?: boolean,
    separator?: string,
    override?: boolean,
    duplicate?: boolean,
};

declare type HapiServerStateCookieOptions = {
    /** time-to-live in milliseconds. Defaults to null (session time-life - cookies are deleted when the browser is closed). */
	ttl?: number | null,

    /** sets the 'Secure' flag. Defaults to true. */
	isSecure?: boolean,

    /** sets the 'HttpOnly' flag. Defaults to true. */
	isHttpOnly?: boolean,

    /**
     * sets the 'SameSite' flag. The value must be one of:
     *  * false - no flag.
     *  * 'Strict' - sets the value to 'Strict' (this is the default value).
     *  * 'Lax' - sets the value to 'Lax'.
     */
	isSameSite?: false | 'Strict' | 'Lax',

    /** the path scope. Defaults to null (no path). */
	path?: string | null,

    /** the domain scope. Defaults to null (no domain). */
    domain?: string | null,

    /**
     * if present and the cookie was not received from the client or explicitly set by the route handler, the
     * cookie is automatically added to the response with the provided value. The value can be
     * a function with signature async function(request) where:
     */
	autoValue?: (request: HapiRequest) => void,

    /**
     * encoding performs on the provided value before serialization. Options are:
     *  * 'none' - no encoding. When used, the cookie value must be a string. This is the default value.
     *  * 'base64' - string value is encoded using Base64.
     *  * 'base64json' - object value is JSON-stringified then encoded using Base64.
     *  * 'form' - object value is encoded using the x-www-form-urlencoded method.
     *  * 'iron' - Encrypts and sign the value using iron.
     */
	encoding?: 'none' | 'base64' | 'base64json' | 'form' | 'iron',

    /**
     * an object used to calculate an HMAC for cookie integrity validation. This does not provide privacy, only a mean
     * to verify that the cookie value was generated by the server. Redundant when 'iron' encoding is used. Options are:
     *  * integrity - algorithm options. Defaults to require('iron').defaults.integrity.
     *  * password - password used for HMAC key generation (must be at least 32 characters long).
     */
    sign?: {
        integrity?: SealOptionsSub,
        password: string,
	},

    /** password used for 'iron' encoding (must be at least 32 characters long). */
	password?: string,

    /** options for 'iron' encoding. Defaults to require('iron').defaults. */
	iron?: SealOptions,

    /** if true, errors are ignored and treated as missing cookies. */
	ignoreErrors?: boolean,

    /** if true, automatically instruct the client to remove invalid cookies. Defaults to false. */
	clearInvalid?: boolean,

    /** if false, allows any cookie value including values in violation of RFC 6265. Defaults to true. */
	strictHeader?: boolean,

    /** used by proxy plugins (e.g. h2o2). */
    passThrough?: any;
}

declare type HapiAuthenticationData = {
    credentials: Object,
    artifacts?: Object,
};

declare type HapiServer = {
	app: {
		logger: (...args: Array<any>) => void,
	},
	expose: (key: string, value: any) => void,
	settings: {
		app: { isProd: boolean, supportedLangs: Array<string>, [string]: any },
		api: { host: string, isProd: boolean },
	},
	plugins: {
		[string]: any,
	},
	route: (routes: HapiRoute | Array<HapiRoute>) => Promise<HapiServer>,
	events: {
		on: (eventName: string, cb: () => void) => void,
	}
};

declare type HapiRequest = {
	getLanguage: () => string,
	getLangPrefixPath: () => string,
	log: (Array<string>, string) => void,
	url: HapiRequestUrl,
	server: HapiServer,
	state: {
		[string]: string,
	},
	info: {
		referrer: string,
		host: string,
		[string]: mixed,
	},
	headers: {
		[string]: string,
	},
	[string]: any,
};

declare type HapiResponseValue = string | Object;

declare type HapiResponseObject = {
	app: HapiApplicationState,
	events: HapiResponseEvents,
	headers: any,
	plugins: HapiPluginsStates,
	settings: HapiResponseSettings,
	source: any,
	statusCode: number,
	variety: 'plain' | 'buffer' | 'stream',
	bytes: (length: number) => HapiResponseObject,
	charset: (charset: string) => HapiResponseObject,
	code: (statusCode: number) => HapiResponseObject,
	message: (httpMessage: string) => HapiResponseObject,
	created: (uri: string) => HapiResponseObject,
	encoding: (encoding: 'ascii' | 'utf8' | 'utf16le' | 'ucs2' | 'base64' | 'latin1' | 'binary' | 'hex') => HapiResponseObject,
	etag: (tag: string, options?: {weak: boolean, vary: boolean}) => HapiResponseObject,
	header: (name: string, value: string, options?: HapiResponseObjectHeaderOptions) => HapiResponseObject,
	location: (uri: string) => HapiResponseObject,
	redirect: (uri: string) => HapiResponseObject,
	replacer: any,
	spaces: (count: number) => HapiResponseObject,
	state: (name: string, value: Object | string, options?: HapiServerStateCookieOptions) => HapiResponseObject,
	suffix: (suffix: string) => HapiResponseObject,
	ttl: (msec: number) => HapiResponseObject,
	type: (mimeType: string) => HapiResponseObject,
	unstate: (name: string, options?: HapiServerStateCookieOptions) => HapiResponseObject,
	vary: (header: string) => HapiResponseObject,
	takeover: () => HapiResponseObject,
	temporary: (isTemporary: boolean) => HapiResponseObject,
	permanent: (isPermanent: boolean) => HapiResponseObject,
	rewritable: (isRewritable: boolean) => HapiResponseObject,
};

declare type HapiResponseToolkit = {
	abandon: any,
	close: any,
	context: any,
	continue: any,
	realm: any,
	request: HapiRequest,
	authenticated: (data: HapiAuthenticationData) => Object,
	entity: (options?: {etag?: string, modified?: string, vary?: boolean}) => HapiResponseObject | void,
	redirect: (uri?: string) => HapiResponseObject,
	response: (value?: HapiResponseValue) => HapiResponseObject,
	state: (key: string, value: string | Object, options?: HapiServerStateCookieOptions) => HapiResponseObject,
	unauthenticated: (error: Error, data?: HapiAuthenticationData) => void,
	unstate: (key: string, options?: HapiServerStateCookieOptions) => HapiResponseObject,
};