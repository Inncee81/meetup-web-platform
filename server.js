module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };

/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};

/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};

/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 44);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

eval("module.exports = require(\"rx\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"rx\"\n// module id = 0\n// module chunks = 0 1 2 3 4 7\n\n//# sourceURL=webpack:///external_%22rx%22?");

/***/ },
/* 1 */
/***/ function(module, exports) {

eval("module.exports = require(\"redux\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"redux\"\n// module id = 1\n// module chunks = 0 1 3 4 5\n\n//# sourceURL=webpack:///external_%22redux%22?");

/***/ },
/* 2 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.loginPost = loginPost;\nexports.configureAuth = configureAuth;\nexports.loginSuccess = loginSuccess;\nexports.loginError = loginError;\nexports.logoutRequest = logoutRequest;\nexports.logoutSuccess = logoutSuccess;\nexports.logoutError = logoutError;\n/**\n * @module authActionCreators\n */\n\n/**\n * Create a 'POST' action with onSuccess that parses the API response and\n * returns either a loginError action (API successfully returned, but the\n * response indicates login failure) or a loginSuccess action. onError always\n * returns a loginError action\n * @param {Object} params object with 'email' and 'password' props\n */\nfunction loginPost(params) {\n\tvar LOGIN_REF = 'login';\n\treturn {\n\t\ttype: 'LOGIN_POST',\n\t\tpayload: {\n\t\t\tquery: {\n\t\t\t\ttype: 'login',\n\t\t\t\tparams: params,\n\t\t\t\tref: LOGIN_REF\n\t\t\t},\n\t\t\tonSuccess: function onSuccess(_ref) {\n\t\t\t\tvar queries = _ref.queries;\n\t\t\t\tvar responses = _ref.responses;\n\n\t\t\t\t// get the response `value`\n\t\t\t\tvar response = responses.slice()[0][LOGIN_REF];\n\t\t\t\t// check for errors reported by API (will be handled by loginError)\n\n\t\t\t\tif (response.value.errors) {\n\t\t\t\t\treturn loginError(response.value.errors);\n\t\t\t\t}\n\t\t\t\t// otherwise return the action\n\t\t\t\treturn loginSuccess(response);\n\t\t\t},\n\t\t\tonError: loginError\n\t\t}\n\t};\n}\n\nfunction configureAuth(auth, isServer) {\n\treturn {\n\t\ttype: 'CONFIGURE_AUTH',\n\t\tpayload: auth,\n\t\tmeta: isServer\n\t};\n}\n\nfunction loginSuccess(response) {\n\treturn {\n\t\ttype: 'LOGIN_SUCCESS',\n\t\tpayload: response\n\t};\n}\n\nfunction loginError(response) {\n\treturn {\n\t\ttype: 'LOGIN_ERROR',\n\t\tpayload: response\n\t};\n}\n\nfunction logoutRequest() {\n\treturn {\n\t\ttype: 'LOGOUT_REQUEST'\n\t};\n}\n\nfunction logoutSuccess(auth) {\n\treturn {\n\t\ttype: 'LOGOUT_SUCCESS',\n\t\tpayload: auth\n\t};\n}\n\nfunction logoutError() {\n\treturn {\n\t\ttype: 'LOGOUT_ERROR'\n\t};\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/actions/authActionCreators.js\n// module id = 2\n// module chunks = 0 3 10\n\n//# sourceURL=webpack:///./src/actions/authActionCreators.js?");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.catchAndReturn$ = undefined;\n\nvar _rx = __webpack_require__(0);\n\nvar _rx2 = _interopRequireDefault(_rx);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Utilities to help with Observable sequences\n *\n * @module rxUtils\n */\n\n/**\n * utility to log errors and return a curried fallback value\n *\n * @param {Object} errorResponse anything to return in an observable\n * @param {Object} log (optional) A logging function\n * @param {Error} error (in curried return function) The error to handle\n * @returns {Observable} single-element observable\n */\nvar catchAndReturn$ = exports.catchAndReturn$ = function catchAndReturn$(errorResponse, log) {\n  return function (error) {\n    log = log || console.log;\n    console.warn('Error: ' + error.message);\n    log(['error'], error.stack);\n\n    return _rx2.default.Observable.just(errorResponse || { error: error });\n  };\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/util/rxUtils.js\n// module id = 3\n// module chunks = 0 2 7\n\n//# sourceURL=webpack:///./src/util/rxUtils.js?");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDuotoneUrls = exports.duotones = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.duotoneRef = duotoneRef;\nexports.generateSignedDuotoneUrl = generateSignedDuotoneUrl;\n\nvar _crypto = __webpack_require__(10);\n\nvar _crypto2 = _interopRequireDefault(_crypto);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Utility methods for working with duotone URLs\n *\n * @module duotone\n */\n\n/**\n * The canonical string reference to a duotone is the 'spec'\n * defined by the photo scaler routing rules.\n *\n * @link www.meetup.com/meetup_api/docs/sign/photo_transform/\n * @param {String} light the hex value for the 'light' color of the duotone\n * @param {String} dark the hex value for the 'dark' color of the duotone\n */\nfunction duotoneRef(light, dark) {\n  return 'dt' + dark + 'x' + light;\n}\n\n// duotone pairs in the format [multiply, screen] (or [light, dark])\nvar HYPERCOLOR = ['ff7900', '7700c8'];\nvar SIZZURP = ['48ffcb', '8a00eb'];\nvar JUNIOR_VARSITY = ['ffc600', '2737ff'];\nvar MIGHTY_DUCKS = ['00d8ff', 'fa002f'];\nvar MERMAID = ['36c200', '002fff'];\nvar GINGER_BEER = ['ffde00', '55005a'];\nvar BUBBLICIOUS = ['ff646a', '000ddf'];\nvar LEMON_LIME = ['fed239', '36c200'];\n\n/**\n * Supported duotone color pairs (hex)\n *\n * @link {https://meetup.atlassian.net/wiki/pages/viewpage.action?pageId=19234854}\n * @const\n */\nvar duotones = exports.duotones = [HYPERCOLOR, SIZZURP, JUNIOR_VARSITY, MIGHTY_DUCKS, MERMAID, GINGER_BEER, BUBBLICIOUS, LEMON_LIME];\n\n/**\n * Server-side utilities for managing signed duotone photo scaler URLs\n *\n * **Important** Do not import this module in client-side code\n *\n* - All duo-toning is done in the photo scaler (http://photos1.meetupstatic.com/photo_api/...)\n *   the duotoned images aren't saved anywhere\n * - The photo scaler requires signed URLs in order to ensure that requests are\n *   coming from \"authorized\" clients that aren't going to DDoS it.\n * - The URL signature corresponds to a particular photo scaler transform 'spec',\n *   including dimensions, which can then be applied to any photo. The REST API\n *   does not provide the duotoned URLs because they tend to be application-\n *   specific - it just returns a pair of hex values corresponding to the\n *   duotone 'light_color' and 'dark_color'.\n * - In order to sign the URL, the application needs a secret salt for the hash,\n *   which means the signing needs to happen on the server for a fixed set of\n *   transformations (one for each duotone color pair).\n * - Once the server has the signed URLs (which never change - they can be\n *   applied to any photo ID), it needs to send them to the client through\n *   application state, which is the only data link that currently exists\n *   between the server and the application.\n *\n * @module duotoneServer\n */\n\n/**\n * Using a passed in *SECRET* salt, generate the photo scaler URL templates\n * in the format described by the sign/photo_transform API. Return the values\n * in an object keyed by the duotone 'spec'\n *\n * @link {https://www.meetup.com/meetup_api/docs/sign/photo_transform/}\n * @param {String} salt The salt used by all platforms generating signed URLs\n * for the photo scaler - this is a shared secret that should *never* be\n * managed on the client\n * @param {Array} duotone [light, dark] hex codes for a duotone pair\n * @return {Object} a [duotoneRef]: URLroot key-value pair\n */\nfunction generateSignedDuotoneUrl(salt, _ref) {\n  var _ref2 = _slicedToArray(_ref, 2);\n\n  var light = _ref2[0];\n  var dark = _ref2[1];\n\n  var ref = duotoneRef(light, dark);\n  var spec = 'event/rx300x400/' + ref;\n  var signature = _crypto2.default.createHash('sha1').update('' + spec + salt).digest('hex').substring(0, 10);\n  return _defineProperty({}, ref, 'http://photos1.meetupstatic.com/photo_api/' + spec + '/sg' + signature);\n}\n\n/**\n * Build the complete \"[ref]: urlroot\" object containing signed url roots for\n * all the supported duotone pairs\n *\n * @param {String} PHOTO_SCALER_SALT **Secret** salt for generating signed urls\n */\nvar getDuotoneUrls = exports.getDuotoneUrls = function getDuotoneUrls(duotones, PHOTO_SCALER_SALT) {\n  return duotones.reduce(function (duotoneMap, _ref4) {\n    var _ref5 = _slicedToArray(_ref4, 2);\n\n    var light = _ref5[0];\n    var dark = _ref5[1];\n    return _extends({}, duotoneMap, generateSignedDuotoneUrl(PHOTO_SCALER_SALT, [light, dark]));\n  }, {});\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/util/duotone.js\n// module id = 4\n// module chunks = 0 2\n\n//# sourceURL=webpack:///./src/util/duotone.js?");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.apiResponseDuotoneSetter = exports.groupDuotoneSetter = exports.apiResponseToQueryResponse = exports.buildRequestArgs = exports.parseApiResponse = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.queryToApiConfig = queryToApiConfig;\nexports.parseRequest = parseRequest;\n\nvar _request = __webpack_require__(12);\n\nvar _request2 = _interopRequireDefault(_request);\n\nvar _rx = __webpack_require__(0);\n\nvar _rx2 = _interopRequireDefault(_rx);\n\nvar _rxUtils = __webpack_require__(3);\n\nvar _duotone = __webpack_require__(4);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar externalRequest$ = _rx2.default.Observable.fromNodeCallback(_request2.default);\n\n/**\n * Given the current request and API server host, proxy the request to the API\n * and return the responses corresponding to the provided queries.\n *\n * This module plugs in to any system that provides a `request` object with:\n * - headers\n * - method ('get'/'post')\n * - query string parameters parsed as a plain object (for GET requests)\n * - payload/body (for POST requests)\n *\n * @module ApiProxy\n */\n\n/**\n * mostly error handling - any case where the API does not satisfy the\n * \"api response\" formatting requirement: plain object containing the requested\n * values\n *\n * This utility is specific to the response format of the API being consumed\n * @param response {String} the raw response body text from an API call\n * @return responseObj the JSON-parsed text, possibly with error info\n */\nvar parseApiResponse = exports.parseApiResponse = function parseApiResponse(response) {\n\tvar responseObj = void 0;\n\ttry {\n\t\tresponseObj = JSON.parse(response);\n\t} catch (e) {\n\t\tthrow new TypeError('API response was not JSON: \"' + response + '\"');\n\t}\n\tif (responseObj && responseObj.problem) {\n\t\tthrow new Error('API problem: ' + responseObj.problem + ': ' + responseObj.details);\n\t}\n\n\treturn responseObj;\n};\n\n/**\n * Translate a query into an API `endpoint` + `params`. The translation is based\n * on the Meetup REST API.\n *\n * This function serves as an adapter between the structure of a query and the\n * API-specific config needed to get that data. Note that *each* required\n * endpoint needs to be manually configured\n *\n * {@link http://www.meetup.com/meetup_api/docs/batch/}\n *\n * @param {Object} query a query object from the application\n * @return {Object} the arguments for api request, including endpoint\n */\nfunction queryToApiConfig(_ref) {\n\tvar type = _ref.type;\n\tvar params = _ref.params;\n\tvar ref = _ref.ref;\n\tvar single = _ref.single;\n\n\tvar pathExtension = void 0;\n\tswitch (type) {\n\t\tcase 'home':\n\t\t\t{\n\t\t\t\tparams.fields = params.fields ? params.fields + ',photo_gradient' : 'photo_gradient';\n\t\t\t\treturn {\n\t\t\t\t\tendpoint: 'self/home',\n\t\t\t\t\tparams: params\n\t\t\t\t};\n\t\t\t}\n\t\tcase 'group':\n\t\t\tparams.fields = params.fields ? params.fields + ',photo_gradient' : 'photo_gradient';\n\t\t\tif (params.self) {\n\t\t\t\treturn {\n\t\t\t\t\tendpoint: 'self/groups',\n\t\t\t\t\tparams: params\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tendpoint: params.urlname,\n\t\t\t\tparams: params\n\t\t\t};\n\t\tcase 'event':\n\t\t\tpathExtension = params.id ? '/' + params.id : '';\n\t\t\tparams.fields = ['rsvp_sample'];\n\t\t\treturn {\n\t\t\t\tendpoint: params.urlname + '/events' + pathExtension,\n\t\t\t\tparams: params\n\t\t\t};\n\t\tcase 'member':\n\t\t\treturn {\n\t\t\t\tendpoint: '2/member/' + params.id,\n\t\t\t\tparams: params\n\t\t\t};\n\t\tcase 'login':\n\t\t\treturn {\n\t\t\t\tendpoint: 'sessions',\n\t\t\t\tparams: params\n\t\t\t};\n\t\tdefault:\n\t\t\tthrow new ReferenceError('No API specified for query type ' + type);\n\t}\n}\n\n/**\n * Join the key-value params object into a querystring-like\n * string. use `encodeURIComponent` _only_ if `doEncode` is provided,\n * otherwise the caller is responsible for encoding\n *\n * @param {Object} params plain object of keys and values to format\n * @return {String}\n */\nfunction urlFormatParams(params, doEncode) {\n\treturn Object.keys(params || {}).reduce(function (dataParams, paramKey) {\n\t\tvar paramValue = doEncode ? encodeURIComponent(params[paramKey]) : params[paramKey];\n\t\tdataParams.push(paramKey + '=' + paramValue);\n\t\treturn dataParams;\n\t}, []).join('&');\n}\n\n/**\n * Transform each query into the arguments needed for a `request` call.\n *\n * Some request options are constant for all queries, and these are curried into\n * a function that can be called with a single query as part of the request\n * stream\n *\n * @see {@link https://www.npmjs.com/package/request}\n *\n * @param {Object} externalRequestOpts request options that will be applied to\n *   every query request\n * @param {Object} apiConfig { endpoint, params }\n *   call)\n * @return {Object} externalRequestOptsQuery argument for the call to\n *   `externalRequest` for the query\n */\nvar buildRequestArgs = exports.buildRequestArgs = function buildRequestArgs(externalRequestOpts) {\n\treturn function (_ref2) {\n\t\tvar endpoint = _ref2.endpoint;\n\t\tvar params = _ref2.params;\n\n\t\tvar externalRequestOptsQuery = _extends({}, externalRequestOpts);\n\t\texternalRequestOptsQuery.url = '/' + endpoint;\n\n\t\tvar dataParams = urlFormatParams(params, externalRequestOptsQuery.method === 'get');\n\n\t\tswitch (externalRequestOptsQuery.method) {\n\t\t\tcase 'get':\n\t\t\t\texternalRequestOptsQuery.url += '?' + dataParams;\n\t\t\t\texternalRequestOptsQuery.headers['X-Meta-Photo-Host'] = 'secure';\n\t\t\t\tbreak;\n\t\t\tcase 'post':\n\t\t\t\texternalRequestOptsQuery.body = dataParams;\n\t\t\t\texternalRequestOptsQuery.headers['content-type'] = 'application/x-www-form-urlencoded';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn externalRequestOptsQuery;\n\t};\n};\n\n/**\n * Format apiResponse to match expected state structure\n *\n * @param {Object} apiResponse JSON-parsed api response data\n */\nvar apiResponseToQueryResponse = exports.apiResponseToQueryResponse = function apiResponseToQueryResponse(_ref3) {\n\tvar _ref4 = _slicedToArray(_ref3, 2);\n\n\tvar response = _ref4[0];\n\tvar query = _ref4[1];\n\treturn _defineProperty({}, query.ref, {\n\t\ttype: query.type,\n\t\tvalue: response\n\t});\n};\n\n/**\n * Parse request for queries and request options\n * @return {Object} { queries, externalRequestOpts }\n */\nfunction parseRequest(request, baseUrl) {\n\tvar headers = request.headers;\n\tvar method = request.method;\n\tvar query = request.query;\n\tvar payload = request.payload;\n\n\n\tvar externalRequestOpts = {\n\t\tbaseUrl: baseUrl,\n\t\tmethod: method,\n\t\theaders: _extends({}, headers), // make a copy to be immutable\n\t\tmode: 'no-cors',\n\t\tagentOptions: {\n\t\t\trejectUnauthorized: baseUrl.indexOf('.dev') === -1\n\t\t}\n\t};\n\n\t// Forward the Hapi request headers from the client query\n\t// except for `host` and `accept-encoding`\n\t// which should be provided by the external api request\n\tdelete externalRequestOpts.headers['host'];\n\tdelete externalRequestOpts.headers['accept-encoding'];\n\tdelete externalRequestOpts.headers['content-length']; // original request content-length is irrelevant\n\n\tvar queriesJSON = request.method === 'get' ? query.queries : payload.queries;\n\tvar queries = JSON.parse(queriesJSON);\n\treturn { queries: queries, externalRequestOpts: externalRequestOpts };\n}\n\n/**\n * From a provided set of signed duotone URLs, create a function that injects\n * the full duotone URL into a group object with the key `duotoneUrl`.\n *\n * @param {Object} duotoneUrls map of `[duotoneRef]: url template root`\n * @param {Object} group group object from API\n * @return {Object} the mutated group object\n */\nvar groupDuotoneSetter = exports.groupDuotoneSetter = function groupDuotoneSetter(duotoneUrls) {\n\treturn function (group) {\n\t\tvar photo = group.key_photo || group.group_photo || {};\n\t\tvar duotoneKey = group.photo_gradient && (0, _duotone.duotoneRef)(group.photo_gradient.light_color, group.photo_gradient.dark_color);\n\t\tvar duotoneUrlRoot = duotoneKey && duotoneUrls[duotoneKey];\n\t\tif (duotoneUrlRoot && photo.id) {\n\t\t\tgroup.duotoneUrl = duotoneUrlRoot + '/' + photo.id + '.jpeg';\n\t\t}\n\t\treturn group;\n\t};\n};\n\n/**\n * From a provided set of signed duotoneUrls, create a function that injects\n * the full duotone URL into an query response containing objects that support\n * duotoned images (anything containing group or event objects\n *\n * @param {Object} duotoneUrls map of `[duotoneRef]: url template root`\n * @param {Object} queryResponse { type: <type>, value: <API object> }\n * @return {Object} the modified queryResponse\n */\nvar apiResponseDuotoneSetter = exports.apiResponseDuotoneSetter = function apiResponseDuotoneSetter(duotoneUrls) {\n\tvar setGroupDuotone = groupDuotoneSetter(duotoneUrls);\n\treturn function (queryResponse) {\n\t\t// inject duotone URLs into any group query response\n\t\tObject.keys(queryResponse).forEach(function (key) {\n\t\t\tvar _queryResponse$key = queryResponse[key];\n\t\t\tvar type = _queryResponse$key.type;\n\t\t\tvar value = _queryResponse$key.value;\n\n\t\t\tvar groups = void 0;\n\t\t\tswitch (type) {\n\t\t\t\tcase 'group':\n\t\t\t\t\tgroups = value instanceof Array ? value : [value];\n\t\t\t\t\tgroups.forEach(setGroupDuotone);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'home':\n\t\t\t\t\tvalue.rows.map(function (_ref6) {\n\t\t\t\t\t\tvar items = _ref6.items;\n\t\t\t\t\t\treturn items;\n\t\t\t\t\t}).forEach(function (items) {\n\t\t\t\t\t\treturn items.filter(function (_ref7) {\n\t\t\t\t\t\t\tvar type = _ref7.type;\n\t\t\t\t\t\t\treturn type === 'group';\n\t\t\t\t\t\t}).forEach(function (_ref8) {\n\t\t\t\t\t\t\tvar group = _ref8.group;\n\t\t\t\t\t\t\treturn setGroupDuotone(group);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t\treturn queryResponse;\n\t};\n};\n\n/**\n * This function transforms a single request to the application server into a\n * parallel array of requests to the API server, and then re-assembles the\n * API responses into an array of 'query responses' - i.e. API responses that\n * are formatted with properties from their corresponding query (ref, type).\n *\n * Most of the `options` for the `externalRequest` are shared for all the API\n * requests, so these are initialized in `parseRequest`. `buildRequestArgs`\n * then curries those into a function that can accept a `query` to write the\n * query-specific options.\n *\n * @param {Request} request Hapi request object\n * @param {Object} baseUrl API server base URL for all API requests\n * @return Array$ contains all API responses corresponding to the provided queries\n */\nvar apiProxy$ = function apiProxy$(_ref9) {\n\tvar baseUrl = _ref9.baseUrl;\n\tvar duotoneUrls = _ref9.duotoneUrls;\n\n\tvar setApiResponseDuotones = apiResponseDuotoneSetter(duotoneUrls);\n\n\treturn function (request) {\n\n\t\t// 1. get the queries and the 'universal' `externalRequestOpts` from the request\n\t\tvar _parseRequest = parseRequest(request, baseUrl);\n\n\t\tvar queries = _parseRequest.queries;\n\t\tvar externalRequestOpts = _parseRequest.externalRequestOpts;\n\n\t\t// 2. curry a function that uses `externalRequestOpts` as a base from which\n\t\t// to build the query-specific API request options object\n\n\t\tvar apiConfigToRequestOptions = buildRequestArgs(externalRequestOpts);\n\n\t\treturn _rx2.default.Observable.from(queries) // create stream of query objects - fan-out\n\t\t.map(queryToApiConfig) // convert query to API-specific config\n\t\t.map(apiConfigToRequestOptions) // API-specific args for api request\n\t\t.do(function (externalRequestOpts) {\n\t\t\treturn request.log(['api'], JSON.stringify(externalRequestOpts.url));\n\t\t}) // logging\n\t\t.concatMap(function (externalRequestOpts) {\n\t\t\treturn externalRequest$(externalRequestOpts);\n\t\t}) // make the API calls - keep order\n\t\t.map(function (_ref10) {\n\t\t\tvar _ref11 = _slicedToArray(_ref10, 2);\n\n\t\t\tvar response = _ref11[0];\n\t\t\tvar body = _ref11[1];\n\t\t\treturn body;\n\t\t}) // ignore Response object, just process body string\n\t\t.map(parseApiResponse) // parse into plain object\n\t\t.catch((0, _rxUtils.catchAndReturn$)()) // return error object instead of response\n\t\t.zipIterable(queries) // zip the apiResponse with corresponding query\n\t\t.map(apiResponseToQueryResponse) // convert apiResponse to app-ready queryResponse\n\t\t.map(setApiResponseDuotones) // special duotone prop\n\t\t.toArray(); // group all responses into a single array - fan-in\n\t};\n};\n\nexports.default = apiProxy$;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api-proxy.js\n// module id = 5\n// module chunks = 0 2\n\n//# sourceURL=webpack:///./src/api-proxy.js?");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.ANONYMOUS_AUTH_APP_PATH = undefined;\n\nvar _jsCookie = __webpack_require__(11);\n\nvar _jsCookie2 = _interopRequireDefault(_jsCookie);\n\nvar _rx = __webpack_require__(0);\n\nvar _rx2 = _interopRequireDefault(_rx);\n\nvar _redux = __webpack_require__(1);\n\nvar _authActionCreators = __webpack_require__(2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Auth middle handles all the server communication and cookie managmenet\n * related to login actions.\n *\n * We assume that the login API provides *both* an auth token and the member\n * object corresponding to the login credentials\n *\n * @module AuthMiddleware\n */\nvar ANONYMOUS_AUTH_APP_PATH = exports.ANONYMOUS_AUTH_APP_PATH = '/anon';\n\n/**\n * login sub responds to only the most recent login request, and can be disposed\n * by a logout\n * @const\n */\nvar loginSub = new _rx2.default.SerialDisposable();\nloginSub.setDisposable(_rx2.default.Disposable.empty);\n\n/**\n * There are 6 login-related actions:\n *\n * 1. 'LOGIN_REQUEST' - send credentials for login\n * 2. 'LOGIN_SUCCESS' - updates local state/cookie from api response\n * 3. 'LOGIN_ERROR' - server failed to login user with supplied credentials\n * 4. 'LOGOUT_REQUEST' - return to default state and request anonymous\n *   auth token from server\n * 5. 'LOGOUT_SUCCESS' - new anonymous auth token returned\n * 6. 'LOGOUT_ERROR' - server failed to get anonymous auth token - fatal\n */\nvar AuthMiddleware = function AuthMiddleware(store) {\n\treturn function (next) {\n\t\treturn function (action) {\n\t\t\tvar actions = (0, _redux.bindActionCreators)({\n\t\t\t\tlogoutSuccess: _authActionCreators.logoutSuccess,\n\t\t\t\tlogoutError: _authActionCreators.logoutError,\n\t\t\t\tconfigureAuth: _authActionCreators.configureAuth\n\t\t\t}, store.dispatch);\n\t\t\tvar response = void 0;\n\t\t\tswitch (action.type) {\n\t\t\t\tcase 'LOGIN_SUCCESS':\n\t\t\t\t\t// parse the login API endpoint response and dispatch\n\t\t\t\t\t// configure auth action\n\t\t\t\t\tresponse = action.payload;\n\t\t\t\t\tactions.configureAuth({\n\t\t\t\t\t\toauth_token: response.value.oauth_token, // currently does not expire\n\t\t\t\t\t\texpires_in: response.value.expires_in || 60 * 60, // seconds\n\t\t\t\t\t\trefresh_token: response.value.refresh_token,\n\t\t\t\t\t\tanonymous: false\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'LOGIN_ERROR':\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'LOGOUT_REQUEST':\n\t\t\t\t\t// immediately clear auth information so no more private data is accessible\n\t\t\t\t\t// - this will put the app in limbo, unable to request any more data until\n\t\t\t\t\t// a new token is provided by `LOGOUT_SUCESS` or a full refresh\n\t\t\t\t\tactions.configureAuth({\n\t\t\t\t\t\tanonymous: true\n\t\t\t\t\t});\n\t\t\t\t\t// Go get a new anonymous oauth token\n\t\t\t\t\tfetch(ANONYMOUS_AUTH_APP_PATH).then(function (response) {\n\t\t\t\t\t\treturn response.json();\n\t\t\t\t\t}).catch(function (e) {\n\t\t\t\t\t\treturn Promise.reject([e]);\n\t\t\t\t\t}).then(actions.logoutSuccess, actions.logoutError);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'LOGOUT_SUCCESS':\n\t\t\t\t\t// anonymous auth has returned new anon oauth token\n\t\t\t\t\tresponse = action.payload;\n\t\t\t\t\t// re-sync the page\n\t\t\t\t\tactions.configureAuth({\n\t\t\t\t\t\tanonymous: true,\n\t\t\t\t\t\toauth_token: response.access_token,\n\t\t\t\t\t\trefresh_token: response.refresh_token,\n\t\t\t\t\t\texpires_in: response.expires_in\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'LOGOUT_ERROR':\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'CONFIGURE_AUTH':\n\t\t\t\t\t// The middleware sets cookies based on `configureAuth` actions, but only\n\t\t\t\t\t// in the browser. `action.meta` is a Boolean indicating whether the\n\t\t\t\t\t// action was dispatched from the server or the browser. If it's from the\n\t\t\t\t\t// server, we should not set cookies\n\t\t\t\t\tif (!action.meta) {\n\t\t\t\t\t\tvar _action$payload = action.payload;\n\t\t\t\t\t\tvar oauth_token = _action$payload.oauth_token;\n\t\t\t\t\t\tvar expires_in = _action$payload.expires_in;\n\t\t\t\t\t\tvar refresh_token = _action$payload.refresh_token;\n\t\t\t\t\t\tvar anonymous = _action$payload.anonymous;\n\n\t\t\t\t\t\tvar expires = expires_in ? 1 / 24 / 3600 * expires_in : 365; // lifetime in *days*\n\n\t\t\t\t\t\t_jsCookie2.default.set('oauth_token', oauth_token || '', { expires: expires });\n\t\t\t\t\t\t_jsCookie2.default.set('refresh_token', refresh_token || '', { expires: 5 * 365 } // 5 year expiration - 'permanent'\n\t\t\t\t\t\t);\n\t\t\t\t\t\t_jsCookie2.default.set('anonymous', anonymous || '', { expires: 5 * 365 } // 'permanent', but refreshes with every login/logout\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn next(action);\n\t\t};\n\t};\n};\n\nexports.default = AuthMiddleware;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/middleware/auth.js\n// module id = 6\n// module chunks = 0 3\n\n//# sourceURL=webpack:///./src/middleware/auth.js?");

/***/ },
/* 7 */,
/* 8 */,
/* 9 */
/***/ function(module, exports) {

eval("module.exports = require(\"chalk\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"chalk\"\n// module id = 9\n// module chunks = 0\n\n//# sourceURL=webpack:///external_%22chalk%22?");

/***/ },
/* 10 */
/***/ function(module, exports) {

eval("module.exports = require(\"crypto\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"crypto\"\n// module id = 10\n// module chunks = 0 2\n\n//# sourceURL=webpack:///external_%22crypto%22?");

/***/ },
/* 11 */
/***/ function(module, exports) {

eval("module.exports = require(\"js-cookie\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"js-cookie\"\n// module id = 11\n// module chunks = 0 3\n\n//# sourceURL=webpack:///external_%22js-cookie%22?");

/***/ },
/* 12 */
/***/ function(module, exports) {

eval("module.exports = require(\"request\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"request\"\n// module id = 12\n// module chunks = 0 2\n\n//# sourceURL=webpack:///external_%22request%22?");

/***/ },
/* 13 */
/***/ function(module, exports) {

eval("module.exports = require(\"boom\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"boom\"\n// module id = 13\n// module chunks = 0\n\n//# sourceURL=webpack:///external_%22boom%22?");

/***/ },
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nexports.checkForDevUrl = checkForDevUrl;\nexports.configureEnv = configureEnv;\nexports.server = server;\nexports.default = start;\n\nvar _https = __webpack_require__(31);\n\nvar _https2 = _interopRequireDefault(_https);\n\nvar _hapi = __webpack_require__(30);\n\nvar _hapi2 = _interopRequireDefault(_hapi);\n\n__webpack_require__(26);\n\nvar _config = __webpack_require__(25);\n\nvar _config2 = _interopRequireDefault(_config);\n\nvar _plugins = __webpack_require__(22);\n\nvar _plugins2 = _interopRequireDefault(_plugins);\n\nvar _routes = __webpack_require__(24);\n\nvar _routes2 = _interopRequireDefault(_routes);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/**\n * @module server\n */\n\n/**\n * determine whether a nested object of values contains a string that contains\n * `.dev.meetup.`\n * @param {String|Object} value string or nested object with\n * values that could be URL strings\n * @return {Boolean} whether the `value` contains a 'dev' URL string\n */\nfunction checkForDevUrl(value) {\n\tswitch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {\n\t\tcase 'string':\n\t\t\treturn value.indexOf('.dev.meetup.') > -1;\n\t\tcase 'object':\n\t\t\treturn Object.keys(value).some(function (key) {\n\t\t\t\treturn checkForDevUrl(value[key]);\n\t\t\t});\n\t}\n\treturn false;\n}\n\n/**\n * Make any environment changes that need to be made in response to the provided\n * config\n * @param {Object} config\n * @return {Object} the original config object\n */\nfunction configureEnv(config) {\n\t// When using .dev.meetup endpoints, ignore self-signed SSL cert\n\tvar USING_DEV_ENDPOINTS = checkForDevUrl(config);\n\t_https2.default.globalAgent.options.rejectUnauthorized = !USING_DEV_ENDPOINTS;\n\n\treturn config;\n}\n\n/**\n * server-starting function\n */\nfunction server(routes, connection) {\n\tvar plugins = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];\n\n\tvar server = new _hapi2.default.Server();\n\n\treturn server.connection(connection).register(plugins).then(function () {\n\t\treturn server.log(['start'], plugins.length + ' plugins registered, assigning routes...');\n\t}).then(function () {\n\t\treturn server.route(routes);\n\t}).then(function () {\n\t\treturn server.log(['start'], routes.length + ' routes assigned, starting server...');\n\t}).then(function () {\n\t\treturn server.start();\n\t}).then(function () {\n\t\treturn server.log(['start'], 'Dev server is listening at ' + server.info.uri);\n\t});\n}\n\n/**\n * The start function applies the rendering function to the correct application\n * route and combines the provided routes and plugins with the base routes\n * and plugins\n *\n * @param {Object} renderRequestMap A mapping of localeCodes to functions that emit\n *   the rendered HTML for the locale-specific request\n * @param {Array} routes additional routes for the app - cannot include a\n *   wildcard route\n * @param {Array} plugins additional plugins for the server, usually to support\n *   features in the additional routes\n * @return {Promise} the Promise returned by Hapi's `server.connection` method\n */\nfunction start(renderRequestMap, options) {\n\tvar routes = options.routes;\n\tvar plugins = options.plugins;\n\tvar localeCodes = options.localeCodes;\n\t// source maps make for better stack traces - we might not want this in\n\t// production if it makes anything slower, though\n\t// (process.env.NODE_ENV === 'production')\n\n\t__webpack_require__(36).install();\n\n\treturn (0, _config2.default)().then(configureEnv).then(function (config) {\n\t\tconfig.localeCodes = localeCodes || ['en-US'];\n\t\tvar baseRoutes = (0, _routes2.default)(renderRequestMap, config);\n\t\tvar finalRoutes = [].concat(_toConsumableArray(routes), _toConsumableArray(baseRoutes));\n\n\t\tvar connection = {\n\t\t\thost: '0.0.0.0',\n\t\t\tport: config.DEV_SERVER_PORT\n\t\t};\n\n\t\tvar finalPlugins = [].concat(_toConsumableArray(plugins), _toConsumableArray((0, _plugins2.default)(config)));\n\n\t\treturn server(finalRoutes, connection, finalPlugins);\n\t});\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/server.js\n// module id = 17\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/server.js?");

/***/ },
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.getConsoleLogPlugin = getConsoleLogPlugin;\nexports.getAnonAuthPlugin = getAnonAuthPlugin;\nexports.default = getPlugins;\n\nvar _good = __webpack_require__(29);\n\nvar _good2 = _interopRequireDefault(_good);\n\nvar _anonAuthPlugin = __webpack_require__(23);\n\nvar _anonAuthPlugin2 = _interopRequireDefault(_anonAuthPlugin);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Hapi plugins for the dev server\n *\n * @module ServerPlugins\n */\n\n/**\n * Provides Hapi process monitoring and console logging\n *\n * @see {@link https://github.com/hapijs/good}\n */\nfunction getConsoleLogPlugin() {\n\treturn {\n\t\tregister: _good2.default,\n\t\toptions: {\n\t\t\tops: false, // no ops reporting (for now)\n\t\t\treporters: {\n\t\t\t\tconsole: [{ // filter events with good-squeeze\n\t\t\t\t\tmodule: 'good-squeeze',\n\t\t\t\t\tname: 'Squeeze',\n\t\t\t\t\targs: [{\n\t\t\t\t\t\terror: '*',\n\t\t\t\t\t\tresponse: '*',\n\t\t\t\t\t\trequest: '*',\n\t\t\t\t\t\tlog: '*'\n\t\t\t\t\t}]\n\t\t\t\t}, { // format with good-console\n\t\t\t\t\tmodule: 'good-console',\n\t\t\t\t\targs: [{\n\t\t\t\t\t\tformat: 'YYYY-MM-DD HH:mm:ss.SSS'\n\t\t\t\t\t}]\n\t\t\t\t}, 'stdout' // pipe to stdout\n\t\t\t\t]\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * configure and return the plugin that will allow requests to get anonymous\n * oauth tokens to communicate with the API\n */\nfunction getAnonAuthPlugin(options) {\n\treturn {\n\t\tregister: _anonAuthPlugin2.default,\n\t\toptions: options\n\t};\n}\n\nfunction getPlugins(config) {\n\treturn [getConsoleLogPlugin(), getAnonAuthPlugin(config)];\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/plugins.js\n// module id = 22\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/plugins.js?");

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.anonAuth$ = exports.getAnonymousAccessToken$ = exports.requestAuthorizer = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.getAnonymousCode$ = getAnonymousCode$;\nexports.default = register;\n\nvar _boom = __webpack_require__(13);\n\nvar _boom2 = _interopRequireDefault(_boom);\n\nvar _chalk = __webpack_require__(9);\n\nvar _chalk2 = _interopRequireDefault(_chalk);\n\nvar _rx = __webpack_require__(0);\n\nvar _rx2 = _interopRequireDefault(_rx);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @module anonAuthPlugin\n */\n\nfunction tryJSON(response) {\n\tvar status = response.status;\n\n\tif (status >= 400) {\n\t\t// status always 200: bugzilla #52128\n\t\tthrow new Error('API responded with error code ' + status);\n\t}\n\treturn response.text().then(function (text) {\n\t\treturn JSON.parse(text);\n\t});\n}\n\nfunction verifyAuth(_ref) {\n\tvar _ref2 = _slicedToArray(_ref, 2);\n\n\tvar request = _ref2[0];\n\tvar auth = _ref2[1];\n\n\tvar keys = Object.keys(auth);\n\tif (!keys.length) {\n\t\tvar errorMessage = 'No auth info provided';\n\t\tconsole.error(_chalk2.default.red(errorMessage), ': application can not fetch data.', 'You might be able to recover by clearing cookies and refreshing');\n\t\tthrow new Error(errorMessage);\n\t}\n\t// there are secret tokens in `auth`, be careful with logging\n\trequest.log(['auth'], 'Authorizing with keys: ' + JSON.stringify(keys));\n}\n\nfunction injectAuthIntoRequest(_ref3) {\n\tvar _ref4 = _slicedToArray(_ref3, 2);\n\n\tvar request = _ref4[0];\n\tvar auth = _ref4[1];\n\n\t// update request with auth info\n\trequest.state.oauth_token = auth.access_token; // this endpoint provides 'access_token' instead of 'oauth_token'\n\trequest.state.refresh_token = auth.refresh_token; // use to get new oauth upon expiration\n\trequest.state.expires_in = auth.expires_in; // TTL for oauth token (in seconds)\n\trequest.state.anonymous = true;\n\n\t// special prop in `request.app` to indicate that this is a new,\n\t// server-provided token, not from the original request, so the cookies\n\t// will need to be set in the response\n\trequest.app.setCookies = true;\n}\n\n/**\n * Curry a function that uses a pre-configured anonymous auth stream to ensure\n * that the passed-in Request contains a valid Oauth token\n *\n * If the Request already has a valid oauth token, it is returned unchanged\n *\n * @param {Observable} auth$ a configured anonymous auth stream from `anonAuth$(config)`\n * @param {Request} request Hapi request to modify with auth token (if necessary)\n */\nvar requestAuthorizer = exports.requestAuthorizer = function requestAuthorizer(auth$) {\n\treturn function (request) {\n\t\t// always need oauth_token, even if it's an anonymous (pre-reg) token\n\t\t// This is 'deferred' because we don't want to start fetching the token\n\t\t// before we know that it's needed\n\t\tvar deferredAuth$ = _rx2.default.Observable.defer(function () {\n\t\t\treturn auth$(request);\n\t\t});\n\n\t\tvar request$ = _rx2.default.Observable.just(request);\n\t\treturn _rx2.default.Observable.if(function () {\n\t\t\treturn request.state.oauth_token;\n\t\t}, request$, request$.zip(deferredAuth$).do(verifyAuth).do(injectAuthIntoRequest).map(function (_ref5) {\n\t\t\tvar _ref6 = _slicedToArray(_ref5, 2);\n\n\t\t\tvar request = _ref6[0];\n\t\t\tvar auth = _ref6[1];\n\t\t\treturn request;\n\t\t}) // throw away auth info\n\t\t);\n\t};\n};\n\n/**\n * Get an anonymous code from the API that can be used to generate an oauth\n * access token\n *\n * @param {Object} config { ANONYMOUS_AUTH_URL, oauth }\n * @param {String} redirect_uri Return url after anonymous grant\n */\nfunction getAnonymousCode$(_ref7, redirect_uri) {\n\tvar ANONYMOUS_AUTH_URL = _ref7.ANONYMOUS_AUTH_URL;\n\tvar oauth = _ref7.oauth;\n\n\tif (!oauth.key) {\n\t\tthrow new ReferenceError('OAuth consumer key is required');\n\t}\n\n\tvar authParams = new URLSearchParams();\n\tauthParams.append('response_type', 'anonymous_code');\n\tauthParams.append('client_id', oauth.key);\n\tauthParams.append('redirect_uri', redirect_uri);\n\tvar anonymousCodeUrl = ANONYMOUS_AUTH_URL + '?' + authParams;\n\tvar requestOpts = {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\tAccept: 'application/json'\n\t\t}\n\t};\n\n\treturn function () {\n\t\tconsole.log('Fetching anonymous auth code from ' + ANONYMOUS_AUTH_URL);\n\t\treturn _rx2.default.Observable.fromPromise(fetch(anonymousCodeUrl, requestOpts)).flatMap(tryJSON).catch(function (error) {\n\t\t\tconsole.log(error.stack);\n\t\t\treturn _rx2.default.Observable.just({ code: null });\n\t\t}).map(function (_ref8) {\n\t\t\tvar code = _ref8.code;\n\t\t\treturn {\n\t\t\t\tgrant_type: 'anonymous_code',\n\t\t\t\ttoken: code\n\t\t\t};\n\t\t});\n\t};\n}\n\n/**\n * Curry the config to generate a function that consumes an anonymous\n * code and returns an oauth access token from the API\n * @param {Object} config object containing the oauth secret and key\n * @param {String} redirect_uri Return url after anonymous grant\n * @param {Object} headers Hapi request headers for anonymous user request\n * @return {Object} the JSON-parsed response from the authorize endpoint\n *   - contains 'access_token', 'refresh_token'\n */\nvar getAnonymousAccessToken$ = exports.getAnonymousAccessToken$ = function getAnonymousAccessToken$(_ref9, redirect_uri) {\n\tvar ANONYMOUS_ACCESS_URL = _ref9.ANONYMOUS_ACCESS_URL;\n\tvar oauth = _ref9.oauth;\n\n\tif (!oauth.key) {\n\t\tthrow new ReferenceError('OAuth consumer key is required');\n\t}\n\tif (!oauth.secret) {\n\t\tthrow new ReferenceError('OAuth consumer secret is required');\n\t}\n\tvar params = {\n\t\tclient_id: oauth.key,\n\t\tclient_secret: oauth.secret,\n\t\tredirect_uri: redirect_uri\n\t};\n\treturn function (headers) {\n\t\tvar requestOpts = {\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\tCookie: headers['cookie'],\n\t\t\t\tAccept: headers['accept'],\n\t\t\t\t'Accept-Language': headers['accept-language'],\n\t\t\t\t'Cache-Control': headers['cache-control']\n\t\t\t}\n\t\t};\n\t\tvar accessParams = Object.keys(params).reduce(function (accessParams, key) {\n\t\t\taccessParams.append(key, params[key]);\n\t\t\treturn accessParams;\n\t\t}, new URLSearchParams());\n\n\t\treturn function (_ref10) {\n\t\t\tvar grant_type = _ref10.grant_type;\n\t\t\tvar token = _ref10.token;\n\n\n\t\t\tif (!token) {\n\t\t\t\tthrow new ReferenceError('No auth code provided - cannot obtain access token');\n\t\t\t}\n\n\t\t\taccessParams.append('grant_type', grant_type);\n\t\t\tif (grant_type === 'anonymous_code') {\n\t\t\t\taccessParams.append('code', token);\n\t\t\t}\n\t\t\tif (grant_type === 'refresh_token') {\n\t\t\t\taccessParams.append('refresh_token', token);\n\t\t\t}\n\n\t\t\tvar url = ANONYMOUS_ACCESS_URL + '?' + accessParams;\n\n\t\t\tconsole.log('Fetching anonymous access_token from ' + ANONYMOUS_ACCESS_URL);\n\t\t\treturn _rx2.default.Observable.fromPromise(fetch(url, requestOpts)).flatMap(tryJSON);\n\t\t};\n\t};\n};\n\n/**\n * Curry a function that will get an anonymous auth token for a passed-in request\n * The request header information is used to determine the location and language of the\n * expected anonymous member\n *\n * @param {Object} config { ANONYMOUS_AUTH_URL, ANONYMOUS_ACCESS_URL, oauth }\n * @param {String} redirect_uri this will be ignored since we get the code async,\n * but it must be within the domain registered with the app's oauth consumer\n * config (currently http://www.meetup.com)\n * @param {Object} headers these headers are mainly used to pass along the\n * language setting of the browser so that the anonymous token will access\n * translated API content\n */\nvar anonAuth$ = exports.anonAuth$ = function anonAuth$(config) {\n\tvar redirect_uri = 'http://www.meetup.com/'; // required param set in oauth consumer config\n\tvar code$ = getAnonymousCode$(config, redirect_uri);\n\tvar token$ = getAnonymousAccessToken$(config, redirect_uri);\n\n\t// if the request has a refresh_token, use it. Otherwise, get a new anonymous code\n\treturn function (request) {\n\t\treturn _rx2.default.Observable.if(function () {\n\t\t\treturn request.state.refresh_token;\n\t\t}, _rx2.default.Observable.just({\n\t\t\tgrant_type: 'refresh_token',\n\t\t\ttoken: request.state.refresh_token\n\t\t}), code$()).flatMap(token$(request.headers)).catch(function (error) {\n\t\t\tconsole.log(error.stack);\n\t\t\treturn _rx2.default.Observable.just({}); // failure results in empty object response - bad time\n\t\t});\n\t};\n};\n\n/**\n * This plugin does two things.\n *\n * 1. Adds an 'authorize' interface on the Hapi `request`, which ensures that\n * the request has an oauth_token cookie - it provides an anonymous token when\n * none is provided in the request\n * 2. Adds a new route that returns the anonymous auth JSON containing an\n * anonymous oauth_token (configurable, defaults to '/anon')\n *\n * {@link http://hapijs.com/tutorials/plugins}\n */\nfunction register(server, options, next) {\n\t// create a single anonAuth$ stream that can be used by any route\n\tvar auth$ = anonAuth$(options);\n\t// create a single stream for modifying an arbitrary request with anonymous auth\n\tvar authorizeRequest$ = requestAuthorizer(auth$);\n\n\tserver.decorate('request', 'authorize', function (request) {\n\t\treturn function () {\n\t\t\treturn authorizeRequest$(request);\n\t\t};\n\t}, { apply: true });\n\n\tserver.route({\n\t\tmethod: 'GET',\n\t\tpath: options.ANONYMOUS_AUTH_APP_PATH,\n\t\thandler: function handler(request, reply) {\n\t\t\tauth$(request).subscribe(function (auth) {\n\t\t\t\treply(JSON.stringify(auth)).type('application/json');\n\t\t\t}, function (err) {\n\t\t\t\treply(_boom2.default.badImplementation(err.message));\n\t\t\t});\n\t\t}\n\t});\n\n\tnext();\n}\nregister.attributes = {\n\tname: 'anonAuth',\n\tversion: '1.0.0'\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/plugins/anonAuthPlugin.js\n// module id = 23\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/plugins/anonAuthPlugin.js?");

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = getRoutes;\n\nvar _accepts = __webpack_require__(28);\n\nvar _accepts2 = _interopRequireDefault(_accepts);\n\nvar _boom = __webpack_require__(13);\n\nvar _boom2 = _interopRequireDefault(_boom);\n\nvar _chalk = __webpack_require__(9);\n\nvar _chalk2 = _interopRequireDefault(_chalk);\n\nvar _apiProxy = __webpack_require__(5);\n\nvar _apiProxy2 = _interopRequireDefault(_apiProxy);\n\nvar _duotone = __webpack_require__(4);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getRoutes(renderRequestMap, _ref) {\n\tvar API_SERVER_ROOT_URL = _ref.API_SERVER_ROOT_URL;\n\tvar PHOTO_SCALER_SALT = _ref.PHOTO_SCALER_SALT;\n\tvar localeCodes = _ref.localeCodes;\n\n\n\tconsole.log(_chalk2.default.green('Supported languages:\\n' + Object.keys(renderRequestMap).join('\\n')));\n\tvar proxyApiRequest$ = (0, _apiProxy2.default)({\n\t\tbaseUrl: API_SERVER_ROOT_URL,\n\t\tduotoneUrls: (0, _duotone.getDuotoneUrls)(_duotone.duotones, PHOTO_SCALER_SALT)\n\t});\n\n\t/**\n  * This handler converts the application-supplied queries into external API\n  * calls, and converts the API call responses into a standard format that\n  * the application expects.\n  *\n  * @returns Array query responses, which are in the format defined\n  *   by `apiAdapter.apiResponseToQueryResponse`\n  */\n\tvar apiProxyRoute = {\n\t\tmethod: ['GET', 'POST', 'DELETE', 'PATCH'],\n\t\tpath: '/api',\n\t\thandler: function handler(request, reply) {\n\t\t\tvar queryResponses$ = proxyApiRequest$(request);\n\t\t\tqueryResponses$.subscribe(function (queryResponses) {\n\t\t\t\treply(JSON.stringify(queryResponses)).type('application/json');\n\t\t\t}, function (err) {\n\t\t\t\treply(_boom2.default.badImplementation(err.message));\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n  * Only one wildcard route for all application GET requests - exceptions are\n  * described in the routes above\n  */\n\tvar applicationRoute = {\n\t\tmethod: 'GET',\n\t\tpath: '/{wild*}',\n\t\thandler: function handler(request, reply) {\n\t\t\tvar requestLanguage = (0, _accepts2.default)(request).language(localeCodes) || 'en-US';\n\n\t\t\trequest.log(['info'], _chalk2.default.green('Request received for ' + request.url.href + ' (' + requestLanguage + ')'));\n\t\t\tvar render$ = request.authorize() // `authorize()` method is supplied by anonAuthPlugin\n\t\t\t.flatMap(renderRequestMap[requestLanguage]);\n\n\t\t\trender$.subscribe(function (_ref2) {\n\t\t\t\tvar result = _ref2.result;\n\t\t\t\tvar statusCode = _ref2.statusCode;\n\n\t\t\t\t// response is sent when this function returns (`nextTick`)\n\t\t\t\tvar response = reply(result).code(statusCode);\n\n\t\t\t\trequest.log(['info'], _chalk2.default.green('HTML response ready'));\n\t\t\t\tif (reply.request.app.setCookies) {\n\t\t\t\t\t// when auth cookies are generated on the server rather than the\n\t\t\t\t\t// original browser request, we need to send the new cookies\n\t\t\t\t\t// back to the browser in the response\n\t\t\t\t\tvar _reply$request$state = reply.request.state;\n\t\t\t\t\tvar oauth_token = _reply$request$state.oauth_token;\n\t\t\t\t\tvar refresh_token = _reply$request$state.refresh_token;\n\t\t\t\t\tvar expires_in = _reply$request$state.expires_in;\n\t\t\t\t\tvar anonymous = _reply$request$state.anonymous;\n\n\t\t\t\t\tvar yearOfMilliseconds = 1000 * 60 * 60 * 24 * 365;\n\n\t\t\t\t\trequest.log(['info'], _chalk2.default.green('Setting cookies ' + Object.keys(reply.request.state)));\n\t\t\t\t\tresponse.state('oauth_token', oauth_token, { ttl: expires_in * 1000 });\n\t\t\t\t\tresponse.state('refresh_token', refresh_token, { ttl: yearOfMilliseconds * 2 });\n\t\t\t\t\tresponse.state('anonymous', anonymous.toString(), { ttl: yearOfMilliseconds * 2 });\n\t\t\t\t}\n\t\t\t}, function (err) {\n\t\t\t\treply(_boom2.default.badImplementation(err.message));\n\t\t\t});\n\t\t}\n\t};\n\n\treturn [apiProxyRoute, applicationRoute];\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/routes.js\n// module id = 24\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/routes.js?");

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = getConfig;\n\nvar _chalk = __webpack_require__(9);\n\nvar _chalk2 = _interopRequireDefault(_chalk);\n\nvar _auth = __webpack_require__(6);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Start the server with a config\n *\n * This module provides a Promise-based interface for assembling a\n * configuration object and passing it to the server startup function.\n * @module config\n */\n\nfunction getConfig(overrideConfig) {\n\t/**\n  * Read all config from environment variables here once on startup\n  */\n\tvar config = {\n\t\tDEV_SERVER_PORT: process.env.DEV_SERVER_PORT || 8000,\n\t\tAPI_PROTOCOL: process.env.API_PROTOCOL || 'https',\n\t\tAPI_HOST: process.env.API_HOST || 'api.dev.meetup.com',\n\t\tANONYMOUS_AUTH_URL: process.env.ANONYMOUS_AUTH_URL || 'https://secure.dev.meetup.com/oauth2/authorize',\n\t\tANONYMOUS_ACCESS_URL: process.env.ANONYMOUS_ACCESS_URL || 'https://secure.dev.meetup.com/oauth2/access',\n\t\tPHOTO_SCALER_SALT: process.env.PHOTO_SCALER_SALT,\n\t\tANONYMOUS_AUTH_APP_PATH: _auth.ANONYMOUS_AUTH_APP_PATH,\n\t\toauth: {\n\t\t\tsecret: process.env.MUPWEB_OAUTH_SECRET,\n\t\t\tkey: process.env.MUPWEB_OAUTH_KEY\n\t\t}\n\t};\n\tconfig.API_SERVER_ROOT_URL = config.API_PROTOCOL + '://' + config.API_HOST;\n\n\t// currently all config is available syncronously, so resolve immediately\n\treturn Promise.resolve(overrideConfig || config).then(validateConfig);\n}\n\nfunction validateConfig(config) {\n\tif (!config) {\n\t\tconsole.log(_chalk2.default.red('No config loaded'));\n\t\treturn false;\n\t}\n\tif (!config.oauth || !config.oauth.secret || !config.oauth.key) {\n\t\tconsole.log(_chalk2.default.red('MUPWEB_OAUTH_SECRET and MUPWEB_OAUTH_KEY must be set as environment variables\\n- get the values from an admin in #web-platform on Slack'));\n\t\treturn false;\n\t}\n\tif (!config.PHOTO_SCALER_SALT) {\n\t\tconsole.log(_chalk2.default.red('PHOTO_SCALER_SALT must be set as an environment variable\\n- get the value from an admin in #web-platform on Slack'));\n\t\treturn false;\n\t}\n\treturn config;\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/util/config.js\n// module id = 25\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/util/config.js?");

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("'use strict';\n\nvar _urlSearchParams = __webpack_require__(37);\n\nvar _urlSearchParams2 = _interopRequireDefault(_urlSearchParams);\n\nvar _nodeFetch = __webpack_require__(32);\n\nvar _nodeFetch2 = _interopRequireDefault(_nodeFetch);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// hello polyfills\nglobal.URLSearchParams = _urlSearchParams2.default;\nglobal.fetch = _nodeFetch2.default;\n\n// runtime values needed by browser and server\nglobal.CONFIG = {\n\tASSET_SERVER_HOST: process.env.ASSET_SERVER_HOST,\n\tASSET_SERVER_PORT: process.env.ASSET_SERVER_PORT\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/util/globals.js\n// module id = 26\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/util/globals.js?");

/***/ },
/* 27 */,
/* 28 */
/***/ function(module, exports) {

eval("module.exports = require(\"accepts\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"accepts\"\n// module id = 28\n// module chunks = 0\n\n//# sourceURL=webpack:///external_%22accepts%22?");

/***/ },
/* 29 */
/***/ function(module, exports) {

eval("module.exports = require(\"good\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"good\"\n// module id = 29\n// module chunks = 0\n\n//# sourceURL=webpack:///external_%22good%22?");

/***/ },
/* 30 */
/***/ function(module, exports) {

eval("module.exports = require(\"hapi\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"hapi\"\n// module id = 30\n// module chunks = 0\n\n//# sourceURL=webpack:///external_%22hapi%22?");

/***/ },
/* 31 */
/***/ function(module, exports) {

eval("module.exports = require(\"https\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"https\"\n// module id = 31\n// module chunks = 0\n\n//# sourceURL=webpack:///external_%22https%22?");

/***/ },
/* 32 */
/***/ function(module, exports) {

eval("module.exports = require(\"node-fetch\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"node-fetch\"\n// module id = 32\n// module chunks = 0\n\n//# sourceURL=webpack:///external_%22node-fetch%22?");

/***/ },
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */
/***/ function(module, exports) {

eval("module.exports = require(\"source-map-support\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"source-map-support\"\n// module id = 36\n// module chunks = 0\n\n//# sourceURL=webpack:///external_%22source-map-support%22?");

/***/ },
/* 37 */
/***/ function(module, exports) {

eval("module.exports = require(\"url-search-params\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"url-search-params\"\n// module id = 37\n// module chunks = 0\n\n//# sourceURL=webpack:///external_%22url-search-params%22?");

/***/ },
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */
/***/ function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(17);\n\n\n//////////////////\n// WEBPACK FOOTER\n// multi server\n// module id = 44\n// module chunks = 0\n\n//# sourceURL=webpack:///multi_server?");

/***/ }
/******/ ]);