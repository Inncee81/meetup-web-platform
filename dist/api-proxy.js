module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };

/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};

/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};

/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 39);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports) {

eval("module.exports = require(\"rx\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"rx\"\n// module id = 0\n// module chunks = 0 1 2 3 4 7\n\n//# sourceURL=webpack:///external_%22rx%22?");

/***/ },

/***/ 11:
/***/ function(module, exports) {

eval("module.exports = require(\"request\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"request\"\n// module id = 11\n// module chunks = 0 2\n\n//# sourceURL=webpack:///external_%22request%22?");

/***/ },

/***/ 3:
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.catchAndReturn$ = undefined;\n\nvar _rx = __webpack_require__(0);\n\nvar _rx2 = _interopRequireDefault(_rx);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Utilities to help with Observable sequences\n *\n * @module rxUtils\n */\n\n/**\n * utility to log errors and return a curried fallback value\n *\n * @param {Object} errorResponse anything to return in an observable\n * @param {Object} log (optional) A logging function\n * @param {Error} error (in curried return function) The error to handle\n * @returns {Observable} single-element observable\n */\nvar catchAndReturn$ = exports.catchAndReturn$ = function catchAndReturn$(errorResponse, log) {\n  return function (error) {\n    log = log || console.log;\n    console.warn('Error: ' + error.message);\n    log(['error'], error.stack);\n\n    return _rx2.default.Observable.just(errorResponse || { error: error });\n  };\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/util/rxUtils.js\n// module id = 3\n// module chunks = 0 2 7\n\n//# sourceURL=webpack:///./src/util/rxUtils.js?");

/***/ },

/***/ 39:
/***/ function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(5);\n\n\n//////////////////\n// WEBPACK FOOTER\n// multi api-proxy\n// module id = 39\n// module chunks = 2\n\n//# sourceURL=webpack:///multi_api-proxy?");

/***/ },

/***/ 4:
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDuotoneUrls = exports.duotones = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.duotoneRef = duotoneRef;\nexports.generateSignedDuotoneUrl = generateSignedDuotoneUrl;\n\nvar _crypto = __webpack_require__(9);\n\nvar _crypto2 = _interopRequireDefault(_crypto);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Utility methods for working with duotone URLs\n *\n * @module duotone\n */\n\n/**\n * The canonical string reference to a duotone is the 'spec'\n * defined by the photo scaler routing rules.\n *\n * @link www.meetup.com/meetup_api/docs/sign/photo_transform/\n * @param {String} light the hex value for the 'light' color of the duotone\n * @param {String} dark the hex value for the 'dark' color of the duotone\n */\nfunction duotoneRef(light, dark) {\n  return 'dt' + dark + 'x' + light;\n}\n\n// duotone pairs in the format [multiply, screen] (or [light, dark])\nvar HYPERCOLOR = ['ff7900', '7700c8'];\nvar SIZZURP = ['48ffcb', '8a00eb'];\nvar JUNIOR_VARSITY = ['ffc600', '2737ff'];\nvar MIGHTY_DUCKS = ['00d8ff', 'fa002f'];\nvar MERMAID = ['36c200', '002fff'];\nvar GINGER_BEER = ['ffde00', '55005a'];\nvar BUBBLICIOUS = ['ff646a', '000ddf'];\nvar LEMON_LIME = ['fed239', '36c200'];\n\n/**\n * Supported duotone color pairs (hex)\n *\n * @link {https://meetup.atlassian.net/wiki/pages/viewpage.action?pageId=19234854}\n * @const\n */\nvar duotones = exports.duotones = [HYPERCOLOR, SIZZURP, JUNIOR_VARSITY, MIGHTY_DUCKS, MERMAID, GINGER_BEER, BUBBLICIOUS, LEMON_LIME];\n\n/**\n * Server-side utilities for managing signed duotone photo scaler URLs\n *\n * **Important** Do not import this module in client-side code\n *\n* - All duo-toning is done in the photo scaler (http://photos1.meetupstatic.com/photo_api/...)\n *   the duotoned images aren't saved anywhere\n * - The photo scaler requires signed URLs in order to ensure that requests are\n *   coming from \"authorized\" clients that aren't going to DDoS it.\n * - The URL signature corresponds to a particular photo scaler transform 'spec',\n *   including dimensions, which can then be applied to any photo. The REST API\n *   does not provide the duotoned URLs because they tend to be application-\n *   specific - it just returns a pair of hex values corresponding to the\n *   duotone 'light_color' and 'dark_color'.\n * - In order to sign the URL, the application needs a secret salt for the hash,\n *   which means the signing needs to happen on the server for a fixed set of\n *   transformations (one for each duotone color pair).\n * - Once the server has the signed URLs (which never change - they can be\n *   applied to any photo ID), it needs to send them to the client through\n *   application state, which is the only data link that currently exists\n *   between the server and the application.\n *\n * @module duotoneServer\n */\n\n/**\n * Using a passed in *SECRET* salt, generate the photo scaler URL templates\n * in the format described by the sign/photo_transform API. Return the values\n * in an object keyed by the duotone 'spec'\n *\n * @link {https://www.meetup.com/meetup_api/docs/sign/photo_transform/}\n * @param {String} salt The salt used by all platforms generating signed URLs\n * for the photo scaler - this is a shared secret that should *never* be\n * managed on the client\n * @param {Array} duotone [light, dark] hex codes for a duotone pair\n * @return {Object} a [duotoneRef]: URLroot key-value pair\n */\nfunction generateSignedDuotoneUrl(salt, _ref) {\n  var _ref2 = _slicedToArray(_ref, 2);\n\n  var light = _ref2[0];\n  var dark = _ref2[1];\n\n  var ref = duotoneRef(light, dark);\n  var spec = 'event/rx300x400/' + ref;\n  var signature = _crypto2.default.createHash('sha1').update('' + spec + salt).digest('hex').substring(0, 10);\n  return _defineProperty({}, ref, 'http://photos1.meetupstatic.com/photo_api/' + spec + '/sg' + signature);\n}\n\n/**\n * Build the complete \"[ref]: urlroot\" object containing signed url roots for\n * all the supported duotone pairs\n *\n * @param {String} PHOTO_SCALER_SALT **Secret** salt for generating signed urls\n */\nvar getDuotoneUrls = exports.getDuotoneUrls = function getDuotoneUrls(duotones, PHOTO_SCALER_SALT) {\n  return duotones.reduce(function (duotoneMap, _ref4) {\n    var _ref5 = _slicedToArray(_ref4, 2);\n\n    var light = _ref5[0];\n    var dark = _ref5[1];\n    return _extends({}, duotoneMap, generateSignedDuotoneUrl(PHOTO_SCALER_SALT, [light, dark]));\n  }, {});\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/util/duotone.js\n// module id = 4\n// module chunks = 0 2\n\n//# sourceURL=webpack:///./src/util/duotone.js?");

/***/ },

/***/ 5:
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.apiResponseDuotoneSetter = exports.groupDuotoneSetter = exports.apiResponseToQueryResponse = exports.buildRequestArgs = exports.parseApiResponse = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.queryToApiConfig = queryToApiConfig;\nexports.parseRequest = parseRequest;\n\nvar _request = __webpack_require__(11);\n\nvar _request2 = _interopRequireDefault(_request);\n\nvar _rx = __webpack_require__(0);\n\nvar _rx2 = _interopRequireDefault(_rx);\n\nvar _rxUtils = __webpack_require__(3);\n\nvar _duotone = __webpack_require__(4);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar externalRequest$ = _rx2.default.Observable.fromNodeCallback(_request2.default);\n\n/**\n * Given the current request and API server host, proxy the request to the API\n * and return the responses corresponding to the provided queries.\n *\n * This module plugs in to any system that provides a `request` object with:\n * - headers\n * - method ('get'/'post')\n * - query string parameters parsed as a plain object (for GET requests)\n * - payload/body (for POST requests)\n *\n * @module ApiProxy\n */\n\n/**\n * mostly error handling - any case where the API does not satisfy the\n * \"api response\" formatting requirement: plain object containing the requested\n * values\n *\n * This utility is specific to the response format of the API being consumed\n * @param response {String} the raw response body text from an API call\n * @return responseObj the JSON-parsed text, possibly with error info\n */\nvar parseApiResponse = exports.parseApiResponse = function parseApiResponse(response) {\n\tvar responseObj = void 0;\n\ttry {\n\t\tresponseObj = JSON.parse(response);\n\t} catch (e) {\n\t\tthrow new TypeError('API response was not JSON: \"' + response + '\"');\n\t}\n\tif (responseObj && responseObj.problem) {\n\t\tthrow new Error('API problem: ' + responseObj.problem + ': ' + responseObj.details);\n\t}\n\n\treturn responseObj;\n};\n\n/**\n * Translate a query into an API `endpoint` + `params`. The translation is based\n * on the Meetup REST API.\n *\n * This function serves as an adapter between the structure of a query and the\n * API-specific config needed to get that data. Note that *each* required\n * endpoint needs to be manually configured\n *\n * {@link http://www.meetup.com/meetup_api/docs/batch/}\n *\n * @param {Object} query a query object from the application\n * @return {Object} the arguments for api request, including endpoint\n */\nfunction queryToApiConfig(_ref) {\n\tvar type = _ref.type;\n\tvar params = _ref.params;\n\tvar ref = _ref.ref;\n\tvar single = _ref.single;\n\n\tvar pathExtension = void 0;\n\tswitch (type) {\n\t\tcase 'home':\n\t\t\t{\n\t\t\t\tparams.fields = params.fields ? params.fields + ',photo_gradient' : 'photo_gradient';\n\t\t\t\treturn {\n\t\t\t\t\tendpoint: 'self/home',\n\t\t\t\t\tparams: params\n\t\t\t\t};\n\t\t\t}\n\t\tcase 'group':\n\t\t\tparams.fields = params.fields ? params.fields + ',photo_gradient' : 'photo_gradient';\n\t\t\tif (params.self) {\n\t\t\t\treturn {\n\t\t\t\t\tendpoint: 'self/groups',\n\t\t\t\t\tparams: params\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tendpoint: params.urlname,\n\t\t\t\tparams: params\n\t\t\t};\n\t\tcase 'event':\n\t\t\tpathExtension = params.id ? '/' + params.id : '';\n\t\t\tparams.fields = ['rsvp_sample'];\n\t\t\treturn {\n\t\t\t\tendpoint: params.urlname + '/events' + pathExtension,\n\t\t\t\tparams: params\n\t\t\t};\n\t\tcase 'member':\n\t\t\treturn {\n\t\t\t\tendpoint: '2/member/' + params.id,\n\t\t\t\tparams: params\n\t\t\t};\n\t\tcase 'login':\n\t\t\treturn {\n\t\t\t\tendpoint: 'sessions',\n\t\t\t\tparams: params\n\t\t\t};\n\t\tdefault:\n\t\t\tthrow new ReferenceError('No API specified for query type ' + type);\n\t}\n}\n\n/**\n * Join the key-value params object into a querystring-like\n * string. use `encodeURIComponent` _only_ if `doEncode` is provided,\n * otherwise the caller is responsible for encoding\n *\n * @param {Object} params plain object of keys and values to format\n * @return {String}\n */\nfunction urlFormatParams(params, doEncode) {\n\treturn Object.keys(params || {}).reduce(function (dataParams, paramKey) {\n\t\tvar paramValue = doEncode ? encodeURIComponent(params[paramKey]) : params[paramKey];\n\t\tdataParams.push(paramKey + '=' + paramValue);\n\t\treturn dataParams;\n\t}, []).join('&');\n}\n\n/**\n * Transform each query into the arguments needed for a `request` call.\n *\n * Some request options are constant for all queries, and these are curried into\n * a function that can be called with a single query as part of the request\n * stream\n *\n * @see {@link https://www.npmjs.com/package/request}\n *\n * @param {Object} externalRequestOpts request options that will be applied to\n *   every query request\n * @param {Object} apiConfig { endpoint, params }\n *   call)\n * @return {Object} externalRequestOptsQuery argument for the call to\n *   `externalRequest` for the query\n */\nvar buildRequestArgs = exports.buildRequestArgs = function buildRequestArgs(externalRequestOpts) {\n\treturn function (_ref2) {\n\t\tvar endpoint = _ref2.endpoint;\n\t\tvar params = _ref2.params;\n\n\t\tvar externalRequestOptsQuery = _extends({}, externalRequestOpts);\n\t\texternalRequestOptsQuery.url = '/' + endpoint;\n\n\t\tvar dataParams = urlFormatParams(params, externalRequestOptsQuery.method === 'get');\n\n\t\tswitch (externalRequestOptsQuery.method) {\n\t\t\tcase 'get':\n\t\t\t\texternalRequestOptsQuery.url += '?' + dataParams;\n\t\t\t\texternalRequestOptsQuery.headers['X-Meta-Photo-Host'] = 'secure';\n\t\t\t\tbreak;\n\t\t\tcase 'post':\n\t\t\t\texternalRequestOptsQuery.body = dataParams;\n\t\t\t\texternalRequestOptsQuery.headers['content-type'] = 'application/x-www-form-urlencoded';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn externalRequestOptsQuery;\n\t};\n};\n\n/**\n * Format apiResponse to match expected state structure\n *\n * @param {Object} apiResponse JSON-parsed api response data\n */\nvar apiResponseToQueryResponse = exports.apiResponseToQueryResponse = function apiResponseToQueryResponse(_ref3) {\n\tvar _ref4 = _slicedToArray(_ref3, 2);\n\n\tvar response = _ref4[0];\n\tvar query = _ref4[1];\n\treturn _defineProperty({}, query.ref, {\n\t\ttype: query.type,\n\t\tvalue: response\n\t});\n};\n\n/**\n * Parse request for queries and request options\n * @return {Object} { queries, externalRequestOpts }\n */\nfunction parseRequest(request, baseUrl) {\n\tvar headers = request.headers;\n\tvar method = request.method;\n\tvar query = request.query;\n\tvar payload = request.payload;\n\n\n\tvar externalRequestOpts = {\n\t\tbaseUrl: baseUrl,\n\t\tmethod: method,\n\t\theaders: _extends({}, headers), // make a copy to be immutable\n\t\tmode: 'no-cors',\n\t\tagentOptions: {\n\t\t\trejectUnauthorized: baseUrl.indexOf('.dev') === -1\n\t\t}\n\t};\n\n\t// Forward the Hapi request headers from the client query\n\t// except for `host` and `accept-encoding`\n\t// which should be provided by the external api request\n\tdelete externalRequestOpts.headers['host'];\n\tdelete externalRequestOpts.headers['accept-encoding'];\n\tdelete externalRequestOpts.headers['content-length']; // original request content-length is irrelevant\n\n\tvar queriesJSON = request.method === 'get' ? query.queries : payload.queries;\n\tvar queries = JSON.parse(queriesJSON);\n\treturn { queries: queries, externalRequestOpts: externalRequestOpts };\n}\n\n/**\n * From a provided set of signed duotone URLs, create a function that injects\n * the full duotone URL into a group object with the key `duotoneUrl`.\n *\n * @param {Object} duotoneUrls map of `[duotoneRef]: url template root`\n * @param {Object} group group object from API\n * @return {Object} the mutated group object\n */\nvar groupDuotoneSetter = exports.groupDuotoneSetter = function groupDuotoneSetter(duotoneUrls) {\n\treturn function (group) {\n\t\tvar photo = group.key_photo || group.group_photo || {};\n\t\tvar duotoneKey = group.photo_gradient && (0, _duotone.duotoneRef)(group.photo_gradient.light_color, group.photo_gradient.dark_color);\n\t\tvar duotoneUrlRoot = duotoneKey && duotoneUrls[duotoneKey];\n\t\tif (duotoneUrlRoot && photo.id) {\n\t\t\tgroup.duotoneUrl = duotoneUrlRoot + '/' + photo.id + '.jpeg';\n\t\t}\n\t\treturn group;\n\t};\n};\n\n/**\n * From a provided set of signed duotoneUrls, create a function that injects\n * the full duotone URL into an query response containing objects that support\n * duotoned images (anything containing group or event objects\n *\n * @param {Object} duotoneUrls map of `[duotoneRef]: url template root`\n * @param {Object} queryResponse { type: <type>, value: <API object> }\n * @return {Object} the modified queryResponse\n */\nvar apiResponseDuotoneSetter = exports.apiResponseDuotoneSetter = function apiResponseDuotoneSetter(duotoneUrls) {\n\tvar setGroupDuotone = groupDuotoneSetter(duotoneUrls);\n\treturn function (queryResponse) {\n\t\t// inject duotone URLs into any group query response\n\t\tObject.keys(queryResponse).forEach(function (key) {\n\t\t\tvar _queryResponse$key = queryResponse[key];\n\t\t\tvar type = _queryResponse$key.type;\n\t\t\tvar value = _queryResponse$key.value;\n\n\t\t\tvar groups = void 0;\n\t\t\tswitch (type) {\n\t\t\t\tcase 'group':\n\t\t\t\t\tgroups = value instanceof Array ? value : [value];\n\t\t\t\t\tgroups.forEach(setGroupDuotone);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'home':\n\t\t\t\t\tvalue.rows.map(function (_ref6) {\n\t\t\t\t\t\tvar items = _ref6.items;\n\t\t\t\t\t\treturn items;\n\t\t\t\t\t}).forEach(function (items) {\n\t\t\t\t\t\treturn items.filter(function (_ref7) {\n\t\t\t\t\t\t\tvar type = _ref7.type;\n\t\t\t\t\t\t\treturn type === 'group';\n\t\t\t\t\t\t}).forEach(function (_ref8) {\n\t\t\t\t\t\t\tvar group = _ref8.group;\n\t\t\t\t\t\t\treturn setGroupDuotone(group);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t\treturn queryResponse;\n\t};\n};\n\n/**\n * This function transforms a single request to the application server into a\n * parallel array of requests to the API server, and then re-assembles the\n * API responses into an array of 'query responses' - i.e. API responses that\n * are formatted with properties from their corresponding query (ref, type).\n *\n * Most of the `options` for the `externalRequest` are shared for all the API\n * requests, so these are initialized in `parseRequest`. `buildRequestArgs`\n * then curries those into a function that can accept a `query` to write the\n * query-specific options.\n *\n * @param {Request} request Hapi request object\n * @param {Object} baseUrl API server base URL for all API requests\n * @return Array$ contains all API responses corresponding to the provided queries\n */\nvar apiProxy$ = function apiProxy$(_ref9) {\n\tvar baseUrl = _ref9.baseUrl;\n\tvar duotoneUrls = _ref9.duotoneUrls;\n\n\tvar setApiResponseDuotones = apiResponseDuotoneSetter(duotoneUrls);\n\n\treturn function (request) {\n\n\t\t// 1. get the queries and the 'universal' `externalRequestOpts` from the request\n\t\tvar _parseRequest = parseRequest(request, baseUrl);\n\n\t\tvar queries = _parseRequest.queries;\n\t\tvar externalRequestOpts = _parseRequest.externalRequestOpts;\n\n\t\t// 2. curry a function that uses `externalRequestOpts` as a base from which\n\t\t// to build the query-specific API request options object\n\n\t\tvar apiConfigToRequestOptions = buildRequestArgs(externalRequestOpts);\n\n\t\treturn _rx2.default.Observable.from(queries) // create stream of query objects - fan-out\n\t\t.map(queryToApiConfig) // convert query to API-specific config\n\t\t.map(apiConfigToRequestOptions) // API-specific args for api request\n\t\t.do(function (externalRequestOpts) {\n\t\t\treturn request.log(['api'], JSON.stringify(externalRequestOpts.url));\n\t\t}) // logging\n\t\t.concatMap(function (externalRequestOpts) {\n\t\t\treturn externalRequest$(externalRequestOpts);\n\t\t}) // make the API calls - keep order\n\t\t.map(function (_ref10) {\n\t\t\tvar _ref11 = _slicedToArray(_ref10, 2);\n\n\t\t\tvar response = _ref11[0];\n\t\t\tvar body = _ref11[1];\n\t\t\treturn body;\n\t\t}) // ignore Response object, just process body string\n\t\t.map(parseApiResponse) // parse into plain object\n\t\t.catch((0, _rxUtils.catchAndReturn$)()) // return error object instead of response\n\t\t.zipIterable(queries) // zip the apiResponse with corresponding query\n\t\t.map(apiResponseToQueryResponse) // convert apiResponse to app-ready queryResponse\n\t\t.map(setApiResponseDuotones) // special duotone prop\n\t\t.toArray(); // group all responses into a single array - fan-in\n\t};\n};\n\nexports.default = apiProxy$;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api-proxy.js\n// module id = 5\n// module chunks = 0 2\n\n//# sourceURL=webpack:///./src/api-proxy.js?");

/***/ },

/***/ 9:
/***/ function(module, exports) {

eval("module.exports = require(\"crypto\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"crypto\"\n// module id = 9\n// module chunks = 0 2\n\n//# sourceURL=webpack:///external_%22crypto%22?");

/***/ }

/******/ });