(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("accepts"), require("boom"), require("chalk"), require("crypto"), require("good"), require("hapi"), require("https"), require("node-fetch"), require("request"), require("rx"), require("source-map-support"), require("url-search-params"));
	else if(typeof define === 'function' && define.amd)
		define("meetup-web-platform", ["accepts", "boom", "chalk", "crypto", "good", "hapi", "https", "node-fetch", "request", "rx", "source-map-support", "url-search-params"], factory);
	else if(typeof exports === 'object')
		exports["meetup-web-platform"] = factory(require("accepts"), require("boom"), require("chalk"), require("crypto"), require("good"), require("hapi"), require("https"), require("node-fetch"), require("request"), require("rx"), require("source-map-support"), require("url-search-params"));
	else
		root["meetup-web-platform"] = factory(root["accepts"], root["boom"], root["chalk"], root["crypto"], root["good"], root["hapi"], root["https"], root["node-fetch"], root["request"], root["rx"], root["source-map-support"], root["url-search-params"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_26__, __WEBPACK_EXTERNAL_MODULE_10__, __WEBPACK_EXTERNAL_MODULE_27__, __WEBPACK_EXTERNAL_MODULE_8__, __WEBPACK_EXTERNAL_MODULE_28__, __WEBPACK_EXTERNAL_MODULE_29__, __WEBPACK_EXTERNAL_MODULE_30__, __WEBPACK_EXTERNAL_MODULE_32__, __WEBPACK_EXTERNAL_MODULE_9__, __WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_36__, __WEBPACK_EXTERNAL_MODULE_37__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };

/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};

/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};

/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 44);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

eval("module.exports = require(\"rx\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"rx\"\n// module id = 0\n// module chunks = 0 1 2 3 4 7\n\n//# sourceURL=webpack:///external_%22rx%22?");

/***/ },
/* 1 */,
/* 2 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rx__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rx___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rx__);\n\n/* harmony export */ __webpack_require__.d(exports, \"catchAndReturn$\", function() { return catchAndReturn$; });\n/**\n * Utilities to help with Observable sequences\n *\n * @module rxUtils\n */\n\n/**\n * utility to log errors and return a curried fallback value\n *\n * @param {Object} errorResponse anything to return in an observable\n * @param {Object} log (optional) A logging function\n * @param {Error} error (in curried return function) The error to handle\n * @returns {Observable} single-element observable\n */\nvar catchAndReturn$ = function catchAndReturn$(errorResponse, log) {\n  return function (error) {\n    log = log || console.log;\n    console.warn('Error: ' + error.message);\n    log(['error'], error.stack);\n\n    return __WEBPACK_IMPORTED_MODULE_0_rx___default.a.Observable.just(errorResponse || { error: error });\n  };\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/util/rxUtils.js\n// module id = 2\n// module chunks = 0 2 7\n\n//# sourceURL=webpack:///./src/util/rxUtils.js?");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_crypto__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_crypto___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_crypto__);\n/* harmony export */ exports[\"a\"] = duotoneRef;\n/* harmony export */ __webpack_require__.d(exports, \"c\", function() { return duotones; });/* unused harmony export generateSignedDuotoneUrl */\n/* harmony export */ __webpack_require__.d(exports, \"b\", function() { return getDuotoneUrls; });var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n/**\n * Utility methods for working with duotone URLs\n *\n * @module duotone\n */\n\n/**\n * The canonical string reference to a duotone is the 'spec'\n * defined by the photo scaler routing rules.\n *\n * @link www.meetup.com/meetup_api/docs/sign/photo_transform/\n * @param {String} light the hex value for the 'light' color of the duotone\n * @param {String} dark the hex value for the 'dark' color of the duotone\n */\nfunction duotoneRef(light, dark) {\n  return 'dt' + dark + 'x' + light;\n}\n\n// duotone pairs in the format [multiply, screen] (or [light, dark])\nvar HYPERCOLOR = ['ff7900', '7700c8'];\nvar SIZZURP = ['48ffcb', '8a00eb'];\nvar JUNIOR_VARSITY = ['ffc600', '2737ff'];\nvar MIGHTY_DUCKS = ['00d8ff', 'fa002f'];\nvar MERMAID = ['36c200', '002fff'];\nvar GINGER_BEER = ['ffde00', '55005a'];\nvar BUBBLICIOUS = ['ff646a', '000ddf'];\nvar LEMON_LIME = ['fed239', '36c200'];\n\n/**\n * Supported duotone color pairs (hex)\n *\n * @link {https://meetup.atlassian.net/wiki/pages/viewpage.action?pageId=19234854}\n * @const\n */\nvar duotones = [HYPERCOLOR, SIZZURP, JUNIOR_VARSITY, MIGHTY_DUCKS, MERMAID, GINGER_BEER, BUBBLICIOUS, LEMON_LIME];\n\n/**\n * Server-side utilities for managing signed duotone photo scaler URLs\n *\n * **Important** Do not import this module in client-side code\n *\n* - All duo-toning is done in the photo scaler (http://photos1.meetupstatic.com/photo_api/...)\n *   the duotoned images aren't saved anywhere\n * - The photo scaler requires signed URLs in order to ensure that requests are\n *   coming from \"authorized\" clients that aren't going to DDoS it.\n * - The URL signature corresponds to a particular photo scaler transform 'spec',\n *   including dimensions, which can then be applied to any photo. The REST API\n *   does not provide the duotoned URLs because they tend to be application-\n *   specific - it just returns a pair of hex values corresponding to the\n *   duotone 'light_color' and 'dark_color'.\n * - In order to sign the URL, the application needs a secret salt for the hash,\n *   which means the signing needs to happen on the server for a fixed set of\n *   transformations (one for each duotone color pair).\n * - Once the server has the signed URLs (which never change - they can be\n *   applied to any photo ID), it needs to send them to the client through\n *   application state, which is the only data link that currently exists\n *   between the server and the application.\n *\n * @module duotoneServer\n */\n\n/**\n * Using a passed in *SECRET* salt, generate the photo scaler URL templates\n * in the format described by the sign/photo_transform API. Return the values\n * in an object keyed by the duotone 'spec'\n *\n * @link {https://www.meetup.com/meetup_api/docs/sign/photo_transform/}\n * @param {String} salt The salt used by all platforms generating signed URLs\n * for the photo scaler - this is a shared secret that should *never* be\n * managed on the client\n * @param {Array} duotone [light, dark] hex codes for a duotone pair\n * @return {Object} a [duotoneRef]: URLroot key-value pair\n */\nfunction generateSignedDuotoneUrl(salt, _ref) {\n  var _ref2 = _slicedToArray(_ref, 2);\n\n  var light = _ref2[0];\n  var dark = _ref2[1];\n\n  var ref = duotoneRef(light, dark);\n  var spec = 'event/rx300x400/' + ref;\n  var signature = __WEBPACK_IMPORTED_MODULE_0_crypto___default.a.createHash('sha1').update('' + spec + salt).digest('hex').substring(0, 10);\n  return _defineProperty({}, ref, 'http://photos1.meetupstatic.com/photo_api/' + spec + '/sg' + signature);\n}\n\n/**\n * Build the complete \"[ref]: urlroot\" object containing signed url roots for\n * all the supported duotone pairs\n *\n * @param {String} PHOTO_SCALER_SALT **Secret** salt for generating signed urls\n */\nvar getDuotoneUrls = function getDuotoneUrls(duotones, PHOTO_SCALER_SALT) {\n  return duotones.reduce(function (duotoneMap, _ref4) {\n    var _ref5 = _slicedToArray(_ref4, 2);\n\n    var light = _ref5[0];\n    var dark = _ref5[1];\n    return _extends({}, duotoneMap, generateSignedDuotoneUrl(PHOTO_SCALER_SALT, [light, dark]));\n  }, {});\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/util/duotone.js\n// module id = 3\n// module chunks = 0 2\n\n//# sourceURL=webpack:///./src/util/duotone.js?");

/***/ },
/* 4 */,
/* 5 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_request__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_request___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_request__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rx__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rx___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rx__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_rxUtils__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_duotone__ = __webpack_require__(3);\n\n/* harmony export */ __webpack_require__.d(exports, \"parseApiResponse\", function() { return parseApiResponse; });/* harmony export */ exports[\"queryToApiConfig\"] = queryToApiConfig;\n/* harmony export */ __webpack_require__.d(exports, \"buildRequestArgs\", function() { return buildRequestArgs; });\n/* harmony export */ __webpack_require__.d(exports, \"apiResponseToQueryResponse\", function() { return apiResponseToQueryResponse; });/* harmony export */ exports[\"parseRequest\"] = parseRequest;\n/* harmony export */ __webpack_require__.d(exports, \"groupDuotoneSetter\", function() { return groupDuotoneSetter; });\n/* harmony export */ __webpack_require__.d(exports, \"apiResponseDuotoneSetter\", function() { return apiResponseDuotoneSetter; });var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nvar externalRequest$ = __WEBPACK_IMPORTED_MODULE_1_rx___default.a.Observable.fromNodeCallback(__WEBPACK_IMPORTED_MODULE_0_request___default.a);\n\n\n\n\n/**\n * Given the current request and API server host, proxy the request to the API\n * and return the responses corresponding to the provided queries.\n *\n * This module plugs in to any system that provides a `request` object with:\n * - headers\n * - method ('get'/'post')\n * - query string parameters parsed as a plain object (for GET requests)\n * - payload/body (for POST requests)\n *\n * @module ApiProxy\n */\n\n/**\n * mostly error handling - any case where the API does not satisfy the\n * \"api response\" formatting requirement: plain object containing the requested\n * values\n *\n * This utility is specific to the response format of the API being consumed\n * @param response {String} the raw response body text from an API call\n * @return responseObj the JSON-parsed text, possibly with error info\n */\nvar parseApiResponse = function parseApiResponse(response) {\n\tvar responseObj = void 0;\n\ttry {\n\t\tresponseObj = JSON.parse(response);\n\t} catch (e) {\n\t\tthrow new TypeError('API response was not JSON: \"' + response + '\"');\n\t}\n\tif (responseObj && responseObj.problem) {\n\t\tthrow new Error('API problem: ' + responseObj.problem + ': ' + responseObj.details);\n\t}\n\n\treturn responseObj;\n};\n\n/**\n * Translate a query into an API `endpoint` + `params`. The translation is based\n * on the Meetup REST API.\n *\n * This function serves as an adapter between the structure of a query and the\n * API-specific config needed to get that data. Note that *each* required\n * endpoint needs to be manually configured\n *\n * {@link http://www.meetup.com/meetup_api/docs/batch/}\n *\n * @param {Object} query a query object from the application\n * @return {Object} the arguments for api request, including endpoint\n */\nfunction queryToApiConfig(_ref) {\n\tvar type = _ref.type;\n\tvar params = _ref.params;\n\tvar ref = _ref.ref;\n\tvar single = _ref.single;\n\n\tvar pathExtension = void 0;\n\tswitch (type) {\n\t\tcase 'home':\n\t\t\t{\n\t\t\t\tparams.fields = params.fields ? params.fields + ',photo_gradient' : 'photo_gradient';\n\t\t\t\treturn {\n\t\t\t\t\tendpoint: 'self/home',\n\t\t\t\t\tparams: params\n\t\t\t\t};\n\t\t\t}\n\t\tcase 'group':\n\t\t\tparams.fields = params.fields ? params.fields + ',photo_gradient' : 'photo_gradient';\n\t\t\tif (params.self) {\n\t\t\t\treturn {\n\t\t\t\t\tendpoint: 'self/groups',\n\t\t\t\t\tparams: params\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tendpoint: params.urlname,\n\t\t\t\tparams: params\n\t\t\t};\n\t\tcase 'event':\n\t\t\tpathExtension = params.id ? '/' + params.id : '';\n\t\t\tparams.fields = ['rsvp_sample'];\n\t\t\treturn {\n\t\t\t\tendpoint: params.urlname + '/events' + pathExtension,\n\t\t\t\tparams: params\n\t\t\t};\n\t\tcase 'member':\n\t\t\treturn {\n\t\t\t\tendpoint: '2/member/' + params.id,\n\t\t\t\tparams: params\n\t\t\t};\n\t\tcase 'login':\n\t\t\treturn {\n\t\t\t\tendpoint: 'sessions',\n\t\t\t\tparams: params\n\t\t\t};\n\t\tdefault:\n\t\t\tthrow new ReferenceError('No API specified for query type ' + type);\n\t}\n}\n\n/**\n * Join the key-value params object into a querystring-like\n * string. use `encodeURIComponent` _only_ if `doEncode` is provided,\n * otherwise the caller is responsible for encoding\n *\n * @param {Object} params plain object of keys and values to format\n * @return {String}\n */\nfunction urlFormatParams(params, doEncode) {\n\treturn Object.keys(params || {}).reduce(function (dataParams, paramKey) {\n\t\tvar paramValue = doEncode ? encodeURIComponent(params[paramKey]) : params[paramKey];\n\t\tdataParams.push(paramKey + '=' + paramValue);\n\t\treturn dataParams;\n\t}, []).join('&');\n}\n\n/**\n * Transform each query into the arguments needed for a `request` call.\n *\n * Some request options are constant for all queries, and these are curried into\n * a function that can be called with a single query as part of the request\n * stream\n *\n * @see {@link https://www.npmjs.com/package/request}\n *\n * @param {Object} externalRequestOpts request options that will be applied to\n *   every query request\n * @param {Object} apiConfig { endpoint, params }\n *   call)\n * @return {Object} externalRequestOptsQuery argument for the call to\n *   `externalRequest` for the query\n */\nvar buildRequestArgs = function buildRequestArgs(externalRequestOpts) {\n\treturn function (_ref2) {\n\t\tvar endpoint = _ref2.endpoint;\n\t\tvar params = _ref2.params;\n\n\t\tvar externalRequestOptsQuery = _extends({}, externalRequestOpts);\n\t\texternalRequestOptsQuery.url = '/' + endpoint;\n\n\t\tvar dataParams = urlFormatParams(params, externalRequestOptsQuery.method === 'get');\n\n\t\tswitch (externalRequestOptsQuery.method) {\n\t\t\tcase 'get':\n\t\t\t\texternalRequestOptsQuery.url += '?' + dataParams;\n\t\t\t\texternalRequestOptsQuery.headers['X-Meta-Photo-Host'] = 'secure';\n\t\t\t\tbreak;\n\t\t\tcase 'post':\n\t\t\t\texternalRequestOptsQuery.body = dataParams;\n\t\t\t\texternalRequestOptsQuery.headers['content-type'] = 'application/x-www-form-urlencoded';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn externalRequestOptsQuery;\n\t};\n};\n\n/**\n * Format apiResponse to match expected state structure\n *\n * @param {Object} apiResponse JSON-parsed api response data\n */\nvar apiResponseToQueryResponse = function apiResponseToQueryResponse(_ref3) {\n\tvar _ref4 = _slicedToArray(_ref3, 2);\n\n\tvar response = _ref4[0];\n\tvar query = _ref4[1];\n\treturn _defineProperty({}, query.ref, {\n\t\ttype: query.type,\n\t\tvalue: response\n\t});\n};\n\n/**\n * Parse request for queries and request options\n * @return {Object} { queries, externalRequestOpts }\n */\nfunction parseRequest(request, baseUrl) {\n\tvar headers = request.headers;\n\tvar method = request.method;\n\tvar query = request.query;\n\tvar payload = request.payload;\n\n\n\tvar externalRequestOpts = {\n\t\tbaseUrl: baseUrl,\n\t\tmethod: method,\n\t\theaders: _extends({}, headers), // make a copy to be immutable\n\t\tmode: 'no-cors',\n\t\tagentOptions: {\n\t\t\trejectUnauthorized: baseUrl.indexOf('.dev') === -1\n\t\t}\n\t};\n\n\t// Forward the Hapi request headers from the client query\n\t// except for `host` and `accept-encoding`\n\t// which should be provided by the external api request\n\tdelete externalRequestOpts.headers['host'];\n\tdelete externalRequestOpts.headers['accept-encoding'];\n\tdelete externalRequestOpts.headers['content-length']; // original request content-length is irrelevant\n\n\tvar queriesJSON = request.method === 'get' ? query.queries : payload.queries;\n\tvar queries = JSON.parse(queriesJSON);\n\treturn { queries: queries, externalRequestOpts: externalRequestOpts };\n}\n\n/**\n * From a provided set of signed duotone URLs, create a function that injects\n * the full duotone URL into a group object with the key `duotoneUrl`.\n *\n * @param {Object} duotoneUrls map of `[duotoneRef]: url template root`\n * @param {Object} group group object from API\n * @return {Object} the mutated group object\n */\nvar groupDuotoneSetter = function groupDuotoneSetter(duotoneUrls) {\n\treturn function (group) {\n\t\tvar photo = group.key_photo || group.group_photo || {};\n\t\tvar duotoneKey = group.photo_gradient && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__util_duotone__[\"a\" /* duotoneRef */])(group.photo_gradient.light_color, group.photo_gradient.dark_color);\n\t\tvar duotoneUrlRoot = duotoneKey && duotoneUrls[duotoneKey];\n\t\tif (duotoneUrlRoot && photo.id) {\n\t\t\tgroup.duotoneUrl = duotoneUrlRoot + '/' + photo.id + '.jpeg';\n\t\t}\n\t\treturn group;\n\t};\n};\n\n/**\n * From a provided set of signed duotoneUrls, create a function that injects\n * the full duotone URL into an query response containing objects that support\n * duotoned images (anything containing group or event objects\n *\n * @param {Object} duotoneUrls map of `[duotoneRef]: url template root`\n * @param {Object} queryResponse { type: <type>, value: <API object> }\n * @return {Object} the modified queryResponse\n */\nvar apiResponseDuotoneSetter = function apiResponseDuotoneSetter(duotoneUrls) {\n\tvar setGroupDuotone = groupDuotoneSetter(duotoneUrls);\n\treturn function (queryResponse) {\n\t\t// inject duotone URLs into any group query response\n\t\tObject.keys(queryResponse).forEach(function (key) {\n\t\t\tvar _queryResponse$key = queryResponse[key];\n\t\t\tvar type = _queryResponse$key.type;\n\t\t\tvar value = _queryResponse$key.value;\n\n\t\t\tvar groups = void 0;\n\t\t\tswitch (type) {\n\t\t\t\tcase 'group':\n\t\t\t\t\tgroups = value instanceof Array ? value : [value];\n\t\t\t\t\tgroups.forEach(setGroupDuotone);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'home':\n\t\t\t\t\tvalue.rows.map(function (_ref6) {\n\t\t\t\t\t\tvar items = _ref6.items;\n\t\t\t\t\t\treturn items;\n\t\t\t\t\t}).forEach(function (items) {\n\t\t\t\t\t\treturn items.filter(function (_ref7) {\n\t\t\t\t\t\t\tvar type = _ref7.type;\n\t\t\t\t\t\t\treturn type === 'group';\n\t\t\t\t\t\t}).forEach(function (_ref8) {\n\t\t\t\t\t\t\tvar group = _ref8.group;\n\t\t\t\t\t\t\treturn setGroupDuotone(group);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t\treturn queryResponse;\n\t};\n};\n\n/**\n * This function transforms a single request to the application server into a\n * parallel array of requests to the API server, and then re-assembles the\n * API responses into an array of 'query responses' - i.e. API responses that\n * are formatted with properties from their corresponding query (ref, type).\n *\n * Most of the `options` for the `externalRequest` are shared for all the API\n * requests, so these are initialized in `parseRequest`. `buildRequestArgs`\n * then curries those into a function that can accept a `query` to write the\n * query-specific options.\n *\n * @param {Request} request Hapi request object\n * @param {Object} baseUrl API server base URL for all API requests\n * @return Array$ contains all API responses corresponding to the provided queries\n */\nvar apiProxy$ = function apiProxy$(_ref9) {\n\tvar baseUrl = _ref9.baseUrl;\n\tvar duotoneUrls = _ref9.duotoneUrls;\n\n\tvar setApiResponseDuotones = apiResponseDuotoneSetter(duotoneUrls);\n\n\treturn function (request) {\n\n\t\t// 1. get the queries and the 'universal' `externalRequestOpts` from the request\n\t\tvar _parseRequest = parseRequest(request, baseUrl);\n\n\t\tvar queries = _parseRequest.queries;\n\t\tvar externalRequestOpts = _parseRequest.externalRequestOpts;\n\n\t\t// 2. curry a function that uses `externalRequestOpts` as a base from which\n\t\t// to build the query-specific API request options object\n\n\t\tvar apiConfigToRequestOptions = buildRequestArgs(externalRequestOpts);\n\n\t\treturn __WEBPACK_IMPORTED_MODULE_1_rx___default.a.Observable.from(queries) // create stream of query objects - fan-out\n\t\t.map(queryToApiConfig) // convert query to API-specific config\n\t\t.map(apiConfigToRequestOptions) // API-specific args for api request\n\t\t.do(function (externalRequestOpts) {\n\t\t\treturn request.log(['api'], JSON.stringify(externalRequestOpts.url));\n\t\t}) // logging\n\t\t.concatMap(function (externalRequestOpts) {\n\t\t\treturn externalRequest$(externalRequestOpts);\n\t\t}) // make the API calls - keep order\n\t\t.map(function (_ref10) {\n\t\t\tvar _ref11 = _slicedToArray(_ref10, 2);\n\n\t\t\tvar response = _ref11[0];\n\t\t\tvar body = _ref11[1];\n\t\t\treturn body;\n\t\t}) // ignore Response object, just process body string\n\t\t.map(parseApiResponse) // parse into plain object\n\t\t.catch(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__util_rxUtils__[\"catchAndReturn$\"])()) // return error object instead of response\n\t\t.zipIterable(queries) // zip the apiResponse with corresponding query\n\t\t.map(apiResponseToQueryResponse) // convert apiResponse to app-ready queryResponse\n\t\t.map(setApiResponseDuotones) // special duotone prop\n\t\t.toArray(); // group all responses into a single array - fan-in\n\t};\n};\n\n/* harmony default export */ exports[\"default\"] = apiProxy$;\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/api-proxy.js\n// module id = 5\n// module chunks = 0 2\n\n//# sourceURL=webpack:///./src/api-proxy.js?");

/***/ },
/* 6 */,
/* 7 */,
/* 8 */
/***/ function(module, exports) {

eval("module.exports = require(\"crypto\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"crypto\"\n// module id = 8\n// module chunks = 0 2\n\n//# sourceURL=webpack:///external_%22crypto%22?");

/***/ },
/* 9 */
/***/ function(module, exports) {

eval("module.exports = require(\"request\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"request\"\n// module id = 9\n// module chunks = 0 2\n\n//# sourceURL=webpack:///external_%22request%22?");

/***/ },
/* 10 */
/***/ function(module, exports) {

eval("module.exports = require(\"boom\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"boom\"\n// module id = 10\n// module chunks = 0\n\n//# sourceURL=webpack:///external_%22boom%22?");

/***/ },
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_https__ = __webpack_require__(30);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_https___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_https__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_hapi__ = __webpack_require__(29);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_hapi___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_hapi__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_globals__ = __webpack_require__(24);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_globals___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__util_globals__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_config__ = __webpack_require__(23);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__plugins__ = __webpack_require__(20);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__routes__ = __webpack_require__(22);\n/* harmony export */ exports[\"checkForDevUrl\"] = checkForDevUrl;/* harmony export */ exports[\"configureEnv\"] = configureEnv;/* harmony export */ exports[\"server\"] = server;/* harmony export */ exports[\"default\"] = start;var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n\n\n\n\n\n\n\n\n\n/**\n * @module server\n */\n\n/**\n * determine whether a nested object of values contains a string that contains\n * `.dev.meetup.`\n * @param {String|Object} value string or nested object with\n * values that could be URL strings\n * @return {Boolean} whether the `value` contains a 'dev' URL string\n */\nfunction checkForDevUrl(value) {\n\tswitch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {\n\t\tcase 'string':\n\t\t\treturn value.indexOf('.dev.meetup.') > -1;\n\t\tcase 'object':\n\t\t\treturn Object.keys(value).some(function (key) {\n\t\t\t\treturn checkForDevUrl(value[key]);\n\t\t\t});\n\t}\n\treturn false;\n}\n\n/**\n * Make any environment changes that need to be made in response to the provided\n * config\n * @param {Object} config\n * @return {Object} the original config object\n */\nfunction configureEnv(config) {\n\t// When using .dev.meetup endpoints, ignore self-signed SSL cert\n\tvar USING_DEV_ENDPOINTS = checkForDevUrl(config);\n\t__WEBPACK_IMPORTED_MODULE_0_https___default.a.globalAgent.options.rejectUnauthorized = !USING_DEV_ENDPOINTS;\n\n\treturn config;\n}\n\n/**\n * server-starting function\n */\nfunction server(routes, connection) {\n\tvar plugins = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];\n\n\tvar server = new __WEBPACK_IMPORTED_MODULE_1_hapi___default.a.Server();\n\n\treturn server.connection(connection).register(plugins).then(function () {\n\t\treturn server.log(['start'], plugins.length + ' plugins registered, assigning routes...');\n\t}).then(function () {\n\t\treturn server.route(routes);\n\t}).then(function () {\n\t\treturn server.log(['start'], routes.length + ' routes assigned, starting server...');\n\t}).then(function () {\n\t\treturn server.start();\n\t}).then(function () {\n\t\treturn server.log(['start'], 'Dev server is listening at ' + server.info.uri);\n\t});\n}\n\n/**\n * The start function applies the rendering function to the correct application\n * route and combines the provided routes and plugins with the base routes\n * and plugins\n *\n * @param {Object} renderRequestMap A mapping of localeCodes to functions that emit\n *   the rendered HTML for the locale-specific request\n * @param {Array} routes additional routes for the app - cannot include a\n *   wildcard route\n * @param {Array} plugins additional plugins for the server, usually to support\n *   features in the additional routes\n * @return {Promise} the Promise returned by Hapi's `server.connection` method\n */\nfunction start(renderRequestMap, options) {\n\tvar routes = options.routes;\n\tvar plugins = options.plugins;\n\tvar localeCodes = options.localeCodes;\n\t// source maps make for better stack traces - we might not want this in\n\t// production if it makes anything slower, though\n\t// (process.env.NODE_ENV === 'production')\n\n\t__webpack_require__(36).install();\n\n\treturn __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__util_config__[\"a\" /* default */])().then(configureEnv).then(function (config) {\n\t\tconfig.localeCodes = localeCodes || ['en-US'];\n\t\tvar baseRoutes = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__routes__[\"a\" /* default */])(renderRequestMap, config);\n\t\tvar finalRoutes = [].concat(_toConsumableArray(routes), _toConsumableArray(baseRoutes));\n\n\t\tvar connection = {\n\t\t\thost: '0.0.0.0',\n\t\t\tport: config.DEV_SERVER_PORT\n\t\t};\n\n\t\tvar finalPlugins = [].concat(_toConsumableArray(plugins), _toConsumableArray(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_4__plugins__[\"a\" /* default */])(config)));\n\n\t\treturn server(finalRoutes, connection, finalPlugins);\n\t});\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/server.js\n// module id = 15\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/server.js?");

/***/ },
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_good__ = __webpack_require__(28);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_good___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_good__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__plugins_anonAuthPlugin__ = __webpack_require__(21);\n/* unused harmony export getConsoleLogPlugin *//* unused harmony export getAnonAuthPlugin *//* harmony export */ exports[\"a\"] = getPlugins;\n\n\n/**\n * Hapi plugins for the dev server\n *\n * @module ServerPlugins\n */\n\n/**\n * Provides Hapi process monitoring and console logging\n *\n * @see {@link https://github.com/hapijs/good}\n */\nfunction getConsoleLogPlugin() {\n\treturn {\n\t\tregister: __WEBPACK_IMPORTED_MODULE_0_good___default.a,\n\t\toptions: {\n\t\t\tops: false, // no ops reporting (for now)\n\t\t\treporters: {\n\t\t\t\tconsole: [{ // filter events with good-squeeze\n\t\t\t\t\tmodule: 'good-squeeze',\n\t\t\t\t\tname: 'Squeeze',\n\t\t\t\t\targs: [{\n\t\t\t\t\t\terror: '*',\n\t\t\t\t\t\tresponse: '*',\n\t\t\t\t\t\trequest: '*',\n\t\t\t\t\t\tlog: '*'\n\t\t\t\t\t}]\n\t\t\t\t}, { // format with good-console\n\t\t\t\t\tmodule: 'good-console',\n\t\t\t\t\targs: [{\n\t\t\t\t\t\tformat: 'YYYY-MM-DD HH:mm:ss.SSS'\n\t\t\t\t\t}]\n\t\t\t\t}, 'stdout' // pipe to stdout\n\t\t\t\t]\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * configure and return the plugin that will allow requests to get anonymous\n * oauth tokens to communicate with the API\n */\nfunction getAnonAuthPlugin(options) {\n\treturn {\n\t\tregister: __WEBPACK_IMPORTED_MODULE_1__plugins_anonAuthPlugin__[\"a\" /* default */],\n\t\toptions: options\n\t};\n}\n\nfunction getPlugins(config) {\n\treturn [getConsoleLogPlugin(), getAnonAuthPlugin(config)];\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/plugins.js\n// module id = 20\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/plugins.js?");

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_boom__ = __webpack_require__(10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_boom___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_boom__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rx__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rx___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rx__);\n/* unused harmony export requestAuthorizer *//* unused harmony export getAnonymousCode$ *//* unused harmony export getAnonymousAccessToken$ *//* unused harmony export anonAuth$ *//* harmony export */ exports[\"a\"] = register;var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n\n\n\n/**\n * @module anonAuthPlugin\n */\n\nfunction tryJSON(response) {\n\tvar status = response.status;\n\n\tif (status >= 400) {\n\t\t// status always 200: bugzilla #52128\n\t\tthrow new Error('API responded with error code ' + status);\n\t}\n\treturn response.text().then(function (text) {\n\t\treturn JSON.parse(text);\n\t});\n}\n\n/**\n * Curry a function that uses a pre-configured anonymous auth stream to ensure\n * that the passed-in Request contains a valid Oauth token\n *\n * If the Request already has a valid oauth token, it is returned unchanged\n *\n * @param {Observable} auth$ a configured anonymous auth stream from `anonAuth$(config)`\n * @param {Request} request Hapi request to modify with auth token (if necessary)\n */\nvar requestAuthorizer = function requestAuthorizer(auth$) {\n\treturn function (request) {\n\t\t// always need oauth_token, even if it's an anonymous (pre-reg) token\n\t\t// This is 'deferred' because we don't want to start fetching the token\n\t\t// before we know that it's needed\n\t\tvar deferredAuth$ = __WEBPACK_IMPORTED_MODULE_1_rx___default.a.Observable.defer(function () {\n\t\t\treturn auth$(request);\n\t\t});\n\n\t\tvar request$ = __WEBPACK_IMPORTED_MODULE_1_rx___default.a.Observable.just(request);\n\t\treturn __WEBPACK_IMPORTED_MODULE_1_rx___default.a.Observable.if(function () {\n\t\t\treturn request.state.oauth_token;\n\t\t}, request$, request$.zip(deferredAuth$).do(function (_ref) {\n\t\t\tvar _ref2 = _slicedToArray(_ref, 2);\n\n\t\t\tvar request = _ref2[0];\n\t\t\tvar auth = _ref2[1];\n\n\t\t\tif (Object.keys(auth).length) {\n\t\t\t\tconsole.log('injecting auth tokens: ' + JSON.stringify(auth));\n\t\t\t} else {\n\t\t\t\tconsole.log('No auth info provided - application will not fetch data');\n\t\t\t}\n\t\t}).map(function (_ref3) {\n\t\t\tvar _ref4 = _slicedToArray(_ref3, 2);\n\n\t\t\tvar request = _ref4[0];\n\t\t\tvar auth = _ref4[1];\n\n\t\t\t// this endpoint provides 'access_token' instead of 'oauth_token'\n\t\t\trequest.state.oauth_token = auth.access_token;\n\t\t\trequest.state.anonymous = true;\n\t\t\treturn request;\n\t\t}));\n\t};\n};\n\n/**\n * Get an anonymous code from the API that can be used to generate an oauth\n * access token\n *\n * @param {Object} config { ANONYMOUS_AUTH_URL, oauth }\n * @param {String} redirect_uri Return url after anonymous grant\n */\nfunction getAnonymousCode$(_ref5, redirect_uri) {\n\tvar ANONYMOUS_AUTH_URL = _ref5.ANONYMOUS_AUTH_URL;\n\tvar oauth = _ref5.oauth;\n\n\tif (!oauth.key) {\n\t\tthrow new ReferenceError('OAuth consumer key is required');\n\t}\n\n\tvar authParams = new URLSearchParams();\n\tauthParams.append('response_type', 'anonymous_code');\n\tauthParams.append('client_id', oauth.key);\n\tauthParams.append('redirect_uri', redirect_uri);\n\tvar anonymousCodeUrl = ANONYMOUS_AUTH_URL + '?' + authParams;\n\tvar requestOpts = {\n\t\tmethod: 'GET',\n\t\theaders: {\n\t\t\tAccept: 'application/json'\n\t\t}\n\t};\n\n\treturn function () {\n\t\tconsole.log('Fetching anonymous auth code from ' + ANONYMOUS_AUTH_URL);\n\t\treturn __WEBPACK_IMPORTED_MODULE_1_rx___default.a.Observable.fromPromise(fetch(anonymousCodeUrl, requestOpts)).flatMap(tryJSON).catch(function (error) {\n\t\t\tconsole.log(error.stack);\n\t\t\treturn __WEBPACK_IMPORTED_MODULE_1_rx___default.a.Observable.just({ code: null });\n\t\t}).map(function (_ref6) {\n\t\t\tvar code = _ref6.code;\n\t\t\treturn code;\n\t\t});\n\t};\n}\n\n/**\n * Curry the config to generate a function that consumes an anonymous\n * code and returns an oauth access token from the API\n * @param {Object} config object containing the oauth secret and key\n * @param {String} redirect_uri Return url after anonymous grant\n * @param {Object} headers Hapi request headers for anonymous user request\n * @return {Object} the JSON-parsed response from the authorize endpoint\n *   - contains 'access_token', 'refresh_token'\n */\nvar getAnonymousAccessToken$ = function getAnonymousAccessToken$(_ref7, redirect_uri) {\n\tvar ANONYMOUS_ACCESS_URL = _ref7.ANONYMOUS_ACCESS_URL;\n\tvar oauth = _ref7.oauth;\n\n\tif (!oauth.key) {\n\t\tthrow new ReferenceError('OAuth consumer key is required');\n\t}\n\tif (!oauth.secret) {\n\t\tthrow new ReferenceError('OAuth consumer secret is required');\n\t}\n\tvar params = {\n\t\tclient_id: oauth.key,\n\t\tclient_secret: oauth.secret,\n\t\tgrant_type: 'anonymous_code',\n\t\tredirect_uri: redirect_uri\n\t};\n\treturn function (headers) {\n\t\tvar requestOpts = {\n\t\t\tmethod: 'POST',\n\t\t\theaders: {\n\t\t\t\tCookie: headers['cookie'],\n\t\t\t\tAccept: headers['accept'],\n\t\t\t\t'Accept-Language': headers['accept-language'],\n\t\t\t\t'Cache-Control': headers['cache-control']\n\t\t\t}\n\t\t};\n\t\tvar accessParams = Object.keys(params).reduce(function (accessParams, key) {\n\t\t\taccessParams.append(key, params[key]);\n\t\t\treturn accessParams;\n\t\t}, new URLSearchParams());\n\n\t\treturn function (code) {\n\t\t\tif (!code) {\n\t\t\t\tthrow new ReferenceError('No auth code provided - cannot obtain access token');\n\t\t\t}\n\t\t\taccessParams.append('code', code);\n\t\t\tvar url = ANONYMOUS_ACCESS_URL + '?' + accessParams;\n\n\t\t\tconsole.log('Fetching anonymous access_token from ' + ANONYMOUS_ACCESS_URL);\n\t\t\treturn __WEBPACK_IMPORTED_MODULE_1_rx___default.a.Observable.fromPromise(fetch(url, requestOpts)).flatMap(tryJSON);\n\t\t};\n\t};\n};\n\n/**\n * Curry a function that will get an anonymous auth token for a passed-in request\n * The request header information is used to determine the location and language of the\n * expected anonymous member\n *\n * @param {Object} config { ANONYMOUS_AUTH_URL, ANONYMOUS_ACCESS_URL, oauth }\n * @param {String} redirect_uri this will be ignored since we get the code async,\n * but it must be within the domain registered with the app's oauth consumer\n * config (currently http://www.meetup.com)\n * @param {Object} headers these headers are mainly used to pass along the\n * language setting of the browser so that the anonymous token will access\n * translated API content\n */\nvar anonAuth$ = function anonAuth$(config) {\n\tvar redirect_uri = 'http://www.meetup.com/'; // required param set in oauth consumer config\n\tvar code$ = getAnonymousCode$(config, redirect_uri);\n\tvar token$ = getAnonymousAccessToken$(config, redirect_uri);\n\n\treturn function (request) {\n\t\treturn code$().flatMap(token$(request.headers)).catch(function (error) {\n\t\t\tconsole.log(error.stack);\n\t\t\treturn __WEBPACK_IMPORTED_MODULE_1_rx___default.a.Observable.just({}); // failure results in empty object response - bad time\n\t\t});\n\t};\n};\n\n/**\n * This plugin does two things.\n *\n * 1. Adds an 'authorize' interface on the Hapi `request`, which ensures that\n * the request has an oauth_token cookie - it provides an anonymous token when\n * none is provided in the request\n * 2. Adds a new route that returns the anonymous auth JSON containing an\n * anonymous oauth_token (configurable, defaults to '/anon')\n *\n * {@link http://hapijs.com/tutorials/plugins}\n */\nfunction register(server, options, next) {\n\t// create a single anonAuth$ stream that can be used by any route\n\tvar auth$ = anonAuth$(options);\n\t// create a single stream for modifying an arbitrary request with anonymous auth\n\tvar authorizeRequest$ = requestAuthorizer(auth$);\n\n\tserver.decorate('request', 'authorize', function (request) {\n\t\treturn function () {\n\t\t\treturn authorizeRequest$(request);\n\t\t};\n\t}, { apply: true });\n\n\tserver.route({\n\t\tmethod: 'GET',\n\t\tpath: options.path || '/anon',\n\t\thandler: function handler(request, reply) {\n\t\t\tauth$(request).subscribe(function (auth) {\n\t\t\t\treply(JSON.stringify(auth)).type('application/json');\n\t\t\t}, function (err) {\n\t\t\t\treply(__WEBPACK_IMPORTED_MODULE_0_boom___default.a.badImplementation(err.message));\n\t\t\t});\n\t\t}\n\t});\n\n\tnext();\n}\nregister.attributes = {\n\tname: 'anonAuth plugin',\n\tversion: '1.0.0'\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/plugins/anonAuthPlugin.js\n// module id = 21\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/plugins/anonAuthPlugin.js?");

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_boom__ = __webpack_require__(10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_boom___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_boom__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_accepts__ = __webpack_require__(26);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_accepts___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_accepts__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__api_proxy__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_duotone__ = __webpack_require__(3);\n/* harmony export */ exports[\"a\"] = getRoutes;\n\n\n\n\n\nfunction getRoutes(renderRequestMap, _ref) {\n\tvar API_SERVER_ROOT_URL = _ref.API_SERVER_ROOT_URL;\n\tvar PHOTO_SCALER_SALT = _ref.PHOTO_SCALER_SALT;\n\tvar localeCodes = _ref.localeCodes;\n\n\tvar proxyApiRequest$ = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_2__api_proxy__[\"default\"])({\n\t\tbaseUrl: API_SERVER_ROOT_URL,\n\t\tduotoneUrls: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__util_duotone__[\"b\" /* getDuotoneUrls */])(__WEBPACK_IMPORTED_MODULE_3__util_duotone__[\"c\" /* duotones */], PHOTO_SCALER_SALT)\n\t});\n\n\t/**\n  * This handler converts the application-supplied queries into external API\n  * calls, and converts the API call responses into a standard format that\n  * the application expects.\n  *\n  * @returns Array query responses, which are in the format defined\n  *   by `apiAdapter.apiResponseToQueryResponse`\n  */\n\tvar apiProxyRoute = {\n\t\tmethod: ['GET', 'POST', 'DELETE', 'PATCH'],\n\t\tpath: '/api',\n\t\thandler: function handler(request, reply) {\n\t\t\tvar queryResponses$ = proxyApiRequest$(request);\n\t\t\tqueryResponses$.subscribe(function (queryResponses) {\n\t\t\t\treply(JSON.stringify(queryResponses)).type('application/json');\n\t\t\t}, function (err) {\n\t\t\t\treply(__WEBPACK_IMPORTED_MODULE_0_boom___default.a.badImplementation(err.message));\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n  * Only one wildcard route for all application GET requests - exceptions are\n  * described in the routes above\n  */\n\tvar applicationRoute = {\n\t\tmethod: 'GET',\n\t\tpath: '/{wild*}',\n\t\thandler: function handler(request, reply) {\n\t\t\tvar requestLanguage = __WEBPACK_IMPORTED_MODULE_1_accepts___default()(request).language(localeCodes) || 'en-US';\n\t\t\trequest.log(['info'], renderRequestMap[requestLanguage]);\n\t\t\tvar render$ = request.authorize() // `authorize()` method is supplied by anonAuthPlugin\n\t\t\t.flatMap(renderRequestMap[requestLanguage]);\n\n\t\t\trender$.subscribe(function (_ref2) {\n\t\t\t\tvar result = _ref2.result;\n\t\t\t\tvar statusCode = _ref2.statusCode;\n\t\t\t\treturn reply(result).code(statusCode);\n\t\t\t}, function (err) {\n\t\t\t\treply(__WEBPACK_IMPORTED_MODULE_0_boom___default.a.badImplementation(err.message));\n\t\t\t});\n\t\t}\n\t};\n\n\treturn [apiProxyRoute, applicationRoute];\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/routes.js\n// module id = 22\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/routes.js?");

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_chalk__ = __webpack_require__(27);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_chalk___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_chalk__);\n/* harmony export */ exports[\"a\"] = getConfig;\n/**\n * Start the server with a config\n *\n * This module provides a Promise-based interface for assembling a\n * configuration object and passing it to the server startup function.\n * @module config\n */\n\nfunction getConfig(overrideConfig) {\n\t/**\n  * Read all config from environment variables here once on startup\n  */\n\tvar config = {\n\t\tDEV_SERVER_PORT: process.env.DEV_SERVER_PORT || 8000,\n\t\tAPI_PROTOCOL: process.env.API_PROTOCOL || 'https',\n\t\tAPI_HOST: process.env.API_HOST || 'api.dev.meetup.com',\n\t\tANONYMOUS_AUTH_URL: process.env.ANONYMOUS_AUTH_URL || 'https://secure.dev.meetup.com/oauth2/authorize',\n\t\tANONYMOUS_ACCESS_URL: process.env.ANONYMOUS_ACCESS_URL || 'https://secure.dev.meetup.com/oauth2/access',\n\t\tPHOTO_SCALER_SALT: process.env.PHOTO_SCALER_SALT,\n\t\toauth: {\n\t\t\tsecret: process.env.MUPWEB_OAUTH_SECRET,\n\t\t\tkey: process.env.MUPWEB_OAUTH_KEY\n\t\t}\n\t};\n\tconfig.API_SERVER_ROOT_URL = config.API_PROTOCOL + '://' + config.API_HOST;\n\n\t// currently all config is available syncronously, so resolve immediately\n\treturn Promise.resolve(overrideConfig || config).then(validateConfig);\n}\n\nfunction validateConfig(config) {\n\tif (!config) {\n\t\tconsole.log(__WEBPACK_IMPORTED_MODULE_0_chalk___default.a.red('No config loaded'));\n\t\treturn false;\n\t}\n\tif (!config.oauth || !config.oauth.secret || !config.oauth.key) {\n\t\tconsole.log(__WEBPACK_IMPORTED_MODULE_0_chalk___default.a.red('MUPWEB_OAUTH_SECRET and MUPWEB_OAUTH_KEY must be set as environment variables\\n- get the values from an admin in #web-platform on Slack'));\n\t\treturn false;\n\t}\n\tif (!config.PHOTO_SCALER_SALT) {\n\t\tconsole.log(__WEBPACK_IMPORTED_MODULE_0_chalk___default.a.red('PHOTO_SCALER_SALT must be set as an environment variable\\n- get the value from an admin in #web-platform on Slack'));\n\t\treturn false;\n\t}\n\treturn config;\n}\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/util/config.js\n// module id = 23\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/util/config.js?");

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_url_search_params__ = __webpack_require__(37);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_url_search_params___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_url_search_params__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_node_fetch__ = __webpack_require__(32);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_node_fetch___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_node_fetch__);\n\n\n\n// hello polyfills\nglobal.URLSearchParams = __WEBPACK_IMPORTED_MODULE_0_url_search_params___default.a;\nglobal.fetch = __WEBPACK_IMPORTED_MODULE_1_node_fetch___default.a;\n\n// runtime values needed by browser and server\nglobal.CONFIG = {\n\tASSET_SERVER_HOST: process.env.ASSET_SERVER_HOST,\n\tASSET_SERVER_PORT: process.env.ASSET_SERVER_PORT\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/util/globals.js\n// module id = 24\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/util/globals.js?");

/***/ },
/* 25 */,
/* 26 */
/***/ function(module, exports) {

eval("module.exports = require(\"accepts\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"accepts\"\n// module id = 26\n// module chunks = 0\n\n//# sourceURL=webpack:///external_%22accepts%22?");

/***/ },
/* 27 */
/***/ function(module, exports) {

eval("module.exports = require(\"chalk\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"chalk\"\n// module id = 27\n// module chunks = 0\n\n//# sourceURL=webpack:///external_%22chalk%22?");

/***/ },
/* 28 */
/***/ function(module, exports) {

eval("module.exports = require(\"good\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"good\"\n// module id = 28\n// module chunks = 0\n\n//# sourceURL=webpack:///external_%22good%22?");

/***/ },
/* 29 */
/***/ function(module, exports) {

eval("module.exports = require(\"hapi\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"hapi\"\n// module id = 29\n// module chunks = 0\n\n//# sourceURL=webpack:///external_%22hapi%22?");

/***/ },
/* 30 */
/***/ function(module, exports) {

eval("module.exports = require(\"https\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"https\"\n// module id = 30\n// module chunks = 0\n\n//# sourceURL=webpack:///external_%22https%22?");

/***/ },
/* 31 */,
/* 32 */
/***/ function(module, exports) {

eval("module.exports = require(\"node-fetch\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"node-fetch\"\n// module id = 32\n// module chunks = 0\n\n//# sourceURL=webpack:///external_%22node-fetch%22?");

/***/ },
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */
/***/ function(module, exports) {

eval("module.exports = require(\"source-map-support\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"source-map-support\"\n// module id = 36\n// module chunks = 0\n\n//# sourceURL=webpack:///external_%22source-map-support%22?");

/***/ },
/* 37 */
/***/ function(module, exports) {

eval("module.exports = require(\"url-search-params\");\n\n//////////////////\n// WEBPACK FOOTER\n// external \"url-search-params\"\n// module id = 37\n// module chunks = 0\n\n//# sourceURL=webpack:///external_%22url-search-params%22?");

/***/ },
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */
/***/ function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(15);\n\n\n//////////////////\n// WEBPACK FOOTER\n// multi server\n// module id = 44\n// module chunks = 0\n\n//# sourceURL=webpack:///multi_server?");

/***/ }
/******/ ])
});
;